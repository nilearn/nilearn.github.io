<!doctypehtml><html lang=en><meta charset=utf-8><meta content=width=device-width,initial-scale=1.0 name=viewport><title>Nilearn: Statistical Analysis for NeuroImaging in Python — Machine learning for NeuroImaging</title><link href=../_static/pygments.css rel=stylesheet><link href=../_static/nature.css rel=stylesheet><link href=../_static/copybutton.css rel=stylesheet><link href=../_static/gallery.css rel=stylesheet><link href=../_static/gallery-binder.css rel=stylesheet><link href=../_static/gallery-dataframe.css rel=stylesheet><script data-url_root=../ id=documentation_options src=../_static/documentation_options.js></script><script src=../_static/jquery.js></script><script src=../_static/underscore.js></script><script src=../_static/doctools.js></script><script src=../_static/clipboard.min.js></script><script src=../_static/copybutton.js></script><link rel="shortcut icon"href=../_static/favicon.ico><link href=../search.html rel=search title=Search><link title="7.2. Downloading statistical maps from the Neurovault repository"href=neurovault.html rel=next><link title="7. Advanced usage: manual pipelines and scaling up"href=index.html rel=prev><meta content=True name=HandheldFriendly><meta content=width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0 name=viewport><meta content="nilearn, neuroimaging, python, neuroscience, machinelearning"name=keywords><script>function updateTopMenuPosition(height, width) {
    if($(window).scrollTop() > height && $(window).outerWidth() > 1024) {
        //begin to scroll
        $('.related-wrapper').css("z-index", 1000);
        $('.related-wrapper').css("position", "sticky");
        $('.related-wrapper').css("top", 0);
        $('.related-wrapper').css("width", width)
    } else {
        //lock it back into place
        $('.related-wrapper').css("position", "relative");
        $('.related-wrapper').css("top", 0)
    }
}

$(function() {
    var banner_height = $('#logo-banner').outerHeight();
    var banner_width = $('#logo-banner').outerWidth();
    var width = $('.related-wrapper').css("height", $('.related').outerHeight());

    updateTopMenuPosition(banner_height, width);

    $(window).scroll(function(event) {
        updateTopMenuPosition(banner_height, width)
    });

    $(window).resize(function(event) {
        var banner_width = $('#logo-banner').outerWidth();
        var menu_height = $('.related').outerHeight();
        $('.related').css("width", banner_width);
        $('.related-wrapper').css("height", menu_height);
        updateTopMenuPosition(banner_height, width)
    })
});</script><script>function updateSideBarPosition(top, offset, sections) {
    var pos = $(window).scrollTop();
    // Lock the table of content to a fixed position once we scroll enough
    var topShift = 2 * offset;
    if(pos > top + topShift + 1) {
        // begin to scroll with sticky menu bar
        var topShift = -topShift + 1;
        if ($(window).outerWidth() < 1024) {
            // compensate top menu that disappears
            topShift -= offset + 1
        }
        $('.sphinxsidebarwrapper').css("position", "fixed");
        $('.sphinxsidebarwrapper').css("top", topShift)
    }
    else {
        //lock it back into place
        $('.sphinxsidebarwrapper').css("position", "relative");
        $('.sphinxsidebarwrapper').css("top",0)
    }

    // Highlight the current section
    i = 0;
    current_section = 0;
    $('a.internal').removeClass('active');
    for(i in sections) {
        if(sections[i] > pos) {
            break
        }
        if($('a.internal[href$="' + i + '"]').is(':visible')){
            current_section = i
        }
    }
    $('a.internal[href$="' + current_section + '"]').addClass('active');
    $('a.internal[href$="' + current_section + '"]').parent().addClass('active')
}

$(function () {
    // Lock the table of content to a fixed position once we scroll enough
    var tocOffset = $('.related-wrapper').outerHeight();
    var marginTop = parseFloat($('.sphinxsidebarwrapper').css('margin-top').replace(/auto/, 0));
    var top = $('.sphinxsidebarwrapper').offset().top - marginTop;
    sections = {};
    url = document.URL.replace(/#.*$/, "");

    // Grab positions of our sections
    $('.headerlink').each(function(){
        sections[this.href.replace(url, '')] = $(this).offset().top - 50
    });

    updateSideBarPosition(top, tocOffset, sections);

    $(window).scroll(function(event) {
        updateSideBarPosition(top, tocOffset, sections)
    });

    $(window).resize(function(event) {
        tocOffset = $('.related-wrapper').outerHeight();
        updateSideBarPosition(top, tocOffset, sections)
    });
});</script><script>var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-41920728-1']);
        _gaq.push(['_trackPageview']);

        (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();</script><body><div id=logo-banner><div class=logo><a href=../index.html> <img alt="Nilearn logo"border=0 src=../_static/nilearn-logo.png> </a></div><div class=tags><ul><li><big><a href=../auto_examples/decoding/plot_haxby_anova_svm.html>SVM</a></big></li><li><small><a href=../connectivity/parcellating.html>Ward clustering</a></small></li><li><a href=../decoding/searchlight.html>Searchlight</a></li><li><big><a href=../connectivity/resting_state_networks.html>ICA</a></big></li><li><a href=../manipulating_images/data_preparation.html>Nifti IO</a></li><li><a href=../modules/reference.html#module-nilearn.datasets>Datasets</a></li></ul></div><div class=banner><h1>Nilearn:</h1><h2>Statistics for NeuroImaging in Python</h2></div><div class=search_form><div class=gcse-search id=cse style=width:100%></div><script>(function() {
        var cx = '017289614950330089114:elrt9qoutrq';
        var gcse = document.createElement('script');
        gcse.type = 'text/javascript';
        gcse.async = true;
        gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
        var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(gcse, s);
      })();</script></div></div><div class=related-wrapper><div aria-label="related navigation"class=related role=navigation><h3>Navigation</h3><ul><li class=right style=margin-right:10px><a title="Python Module Index"href=../py-modindex.html>modules</a></li><li class=right><a title="7.2. Downloading statistical maps from the Neurovault repository"accesskey=N href=neurovault.html>next</a> |</li><li class=right><a title="7. Advanced usage: manual pipelines and scaling up"accesskey=P href=index.html>previous</a> |</li><li><a href=../index.html>Nilearn Home</a> | </li><li><a href=../user_guide.html>User Guide</a> | </li><li><a href=../auto_examples/index.html>Examples</a> | </li><li><a href=../modules/reference.html>Reference</a> | </li><li id=navbar-about><a href=../authors.html>About</a>| </li><li><a href=../glossary.html>Glossary</a>| </li><li><a href=../bibliography.html>Bibliography</a>| </li><li id=navbar-ecosystem><a href=http://www.nipy.org/>Nipy ecosystem</a></li><li class="nav-item nav-item-1"><a href=../user_guide.html>User guide: table of contents</a> »</li><li class="nav-item nav-item-2"><a accesskey=U href=index.html><span class=section-number>7. </span>Advanced usage: manual pipelines and scaling up</a> »</li><li class="nav-item nav-item-this"><a href>Nilearn: Statistical Analysis for NeuroImaging in Python</a></li></ul></div></div><div class=document><div class=documentwrapper><div class=bodywrapper><div class=body role=main><div class=section id=building-your-own-neuroimaging-machine-learning-pipeline><span id=manual-pipeline></span><h1><span class=section-number>7.1. </span>Building your own neuroimaging machine-learning pipeline<a title="Permalink to this headline"class=headerlink href=#building-your-own-neuroimaging-machine-learning-pipeline>¶</a></h1><p>Nilearn comes with code to simplify the use of scikit-learn when dealing with neuroimaging data. For the moment, nilearn is focused on functional MRI data.</p><p>Before using a machine learning tool, we may need to apply the following steps:</p><blockquote><div><ol class="arabic simple"><li><p><a class="reference internal"href=#data-loading><span class="std std-ref">Data loading and preprocessing</span></a> : load Nifti files and check consistency of data</p></li><li><p><a class="reference internal"href=#masking><span class="std std-ref">Masking data</span></a> : if a mask is not provided, one is computed automatically</p></li><li><p><a class="reference internal"href=../manipulating_images/manipulating_images.html#resampling><span class="std std-ref">Resampling images</span></a>: optionally data could be resampled to a different resolution</p></li><li><p><a class="reference internal"href=../manipulating_images/masker_objects.html#temporal-filtering><span class="std std-ref">Temporal Filtering and confound removal</span></a>: detrending, regressing out confounds, normalization</p></li></ol></div></blockquote><div class=section id=data-loading-and-preprocessing><span id=data-loading></span><h2><span class=section-number>7.1.1. </span>Data loading and preprocessing<a title="Permalink to this headline"class=headerlink href=#data-loading-and-preprocessing>¶</a></h2><div class=section id=downloading-the-data><h3><span class=section-number>7.1.1.1. </span>Downloading the data<a title="Permalink to this headline"class=headerlink href=#downloading-the-data>¶</a></h3><p>To run demos, data are retrieved using a function provided by nilearn which downloads a dataset and returns a bunch of paths to the dataset files (more details in <a class="reference internal"href=../manipulating_images/input_output.html#loading-data><span class="std std-ref">Inputing data: file names or image objects</span></a>). We can then proceed loading them as if they were just any other files on our disk. For example, we can download the data from the <a class="reference external"href=http://dx.doi.org/10.1126/science.1063736>Haxby 2001 paper</a></p><div class="highlight-default notranslate"><div class=highlight><pre><span></span><span class=gp>>>> </span><span class=kn>from</span> <span class=nn>nilearn</span> <span class=kn>import</span> <span class=n>datasets</span>
<span class=gp>>>> </span><span class=n>dataset</span> <span class=o>=</span> <span class=n>datasets</span><span class=o>.</span><span class=n>fetch_haxby</span><span class=p>()</span>
</pre></div></div><p><cite>dataset.func</cite> contains filenames referring to dataset files on the disk:</p><div class="highlight-default notranslate"><div class=highlight><pre><span></span><span class=gp>>>> </span><span class=nb>list</span><span class=p>(</span><span class=nb>sorted</span><span class=p>(</span><span class=n>dataset</span><span class=o>.</span><span class=n>keys</span><span class=p>()))</span>
<span class=go>['anat', 'description', 'func', 'mask', 'mask_face', 'mask_face_little', 'mask_house', 'mask_house_little', 'mask_vt', 'session_target']</span>
<span class=gp>>>> </span><span class=n>dataset</span><span class=o>.</span><span class=n>func</span>
<span class=go>['.../haxby2001/subj2/bold.nii.gz']</span>
</pre></div></div><p>Access supplementary information on the dataset:</p><div class="doctest highlight-default notranslate"><div class=highlight><pre><span></span><span class=gp>>>> </span><span class=nb>print</span><span class=p>(</span><span class=n>haxby_dataset</span><span class=p>[</span><span class=s1>'description'</span><span class=p>])</span>
</pre></div></div><p>The complete list of the data-downloading functions can be found in the <a class="reference internal"href=../modules/reference.html#datasets-ref><span class="std std-ref">reference documentation for the datasets</span></a>.</p></div><div class=section id=loading-non-image-data-experiment-description><h3><span class=section-number>7.1.1.2. </span>Loading non image data: experiment description<a title="Permalink to this headline"class=headerlink href=#loading-non-image-data-experiment-description>¶</a></h3><p>An experiment may need additional information about subjects, sessions or experiments. In the Haxby experiment, fMRI data are acquired while presenting different category of pictures to the subject (face, cat, …) and the goal of this experiment is to predict which category is presented to the subjects from the brain activation.</p><p>These conditions are presented as string into a CSV file. The <a class="reference external"href=http://pandas.pydata.org/>pandas</a> function <cite>read_csv</cite> is very useful to load this kind of data.</p><div class="highlight-default notranslate"><div class=highlight><pre><span></span><span class=kn>import</span> <span class=nn>pandas</span> <span class=k>as</span> <span class=nn>pd</span>
<span class=c1># Load behavioral information</span>
<span class=n>behavioral</span> <span class=o>=</span> <span class=n>pd</span><span class=o>.</span><span class=n>read_csv</span><span class=p>(</span><span class=n>haxby_dataset</span><span class=o>.</span><span class=n>session_target</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>delimiter</span><span class=o>=</span><span class=s1>' '</span><span class=p>)</span>
<span class=nb>print</span><span class=p>(</span><span class=n>behavioral</span><span class=p>)</span>

</pre></div></div><div class="admonition seealso"><p class=admonition-title>See also</p><ul class=simple><li><p><a class="reference external"href=http://pandas.pydata.org/>pandas</a> is a very useful Python library to load CSV files and process their data</p></li></ul></div><p>For example, we will now consider only the conditions <em>cat</em> and <em>face</em> from our dataset. This can be done as follows:</p><div class="highlight-default notranslate"><div class=highlight><pre><span></span><span class=n>condition_mask</span> <span class=o>=</span> <span class=n>conditions</span><span class=o>.</span><span class=n>isin</span><span class=p>([</span><span class=s1>'face'</span><span class=p>,</span> <span class=s1>'cat'</span><span class=p>])</span>

</pre></div></div><div class="admonition note"><p class=admonition-title>Note</p><p>If you are not comfortable with this kind of data processing, do not worry: there are plenty of examples in nilearn that allows you to easily load data from provided datasets. Do not hesitate to copy/paste the code and adapt it to your own data format if needed. More information can be found in the <a class="reference internal"href=../manipulating_images/manipulating_images.html#data-manipulation><span class="std std-ref">data manipulation</span></a> section.</p></div></div><div class=section id=masking-the-data-from-4d-image-to-2d-array><span id=masking></span><h3><span class=section-number>7.1.1.3. </span>Masking the data: from 4D image to 2D array<a title="Permalink to this headline"class=headerlink href=#masking-the-data-from-4d-image-to-2d-array>¶</a></h3><p>While functional neuroimaging data consist in 4D images, positioned in a coordinate space (which we will call <a class="reference internal"href=../manipulating_images/input_output.html#niimg><span class="std std-ref">Niimgs</span></a>). For use with the scikit-learn, they need to be converted into 2D arrays of samples and features.</p><p class=centered><strong><a class="reference internal"href=../_images/niimgs.jpg><img alt=niimgs src=../_images/niimgs.jpg style=width:367px;height:163.5px></a> <span style=padding:.5em;font-size:400%>→</span> <a class="reference internal"href=../_images/feature_array.jpg><img alt=arrays src=../_images/feature_array.jpg style=width:115.15px;height:167.3px></a></strong></p><p>We use masking to convert 4D data (i.e. 3D volume over time) into 2D data (i.e. voxels over time). For this purpose, we use the <a class="reference internal"href=../modules/generated/nilearn.input_data.NiftiMasker.html#nilearn.input_data.NiftiMasker title=nilearn.input_data.NiftiMasker><code class="xref py py-class docutils literal notranslate"><span class=pre>NiftiMasker</span></code></a> object, a very powerful data loading tool.</p><div class=section id=applying-a-mask><h4><span class=section-number>7.1.1.3.1. </span>Applying a mask<a title="Permalink to this headline"class=headerlink href=#applying-a-mask>¶</a></h4><div class="figure align-right"><a class="reference external image-reference"href=../auto_examples/plot_decoding_tutorial.html><img alt=../_images/sphx_glr_plot_decoding_tutorial_001.png src=../_images/sphx_glr_plot_decoding_tutorial_001.png style=width:198px;height:78px></a></div><p>If your dataset provides a mask, the <a class="reference internal"href=../modules/generated/nilearn.input_data.NiftiMasker.html#nilearn.input_data.NiftiMasker title=nilearn.input_data.NiftiMasker><code class="xref py py-class docutils literal notranslate"><span class=pre>NiftiMasker</span></code></a> can apply it automatically. All you have to do is to pass your mask as a parameter when creating your masker. Here we use the mask of the ventral stream, provided with the Haxby dataset.</p><p>The <a class="reference internal"href=../modules/generated/nilearn.input_data.NiftiMasker.html#nilearn.input_data.NiftiMasker title=nilearn.input_data.NiftiMasker><code class="xref py py-class docutils literal notranslate"><span class=pre>NiftiMasker</span></code></a> can be seen as a <em>tube</em> that transforms data from 4D images to 2D arrays, but first it needs to ‘fit’ this data in order to learn simple parameters from it, such as its shape:</p><div class="highlight-python notranslate"><div class=highlight><pre><span></span><span class=c1># We first create a masker, giving it the options that we care</span>
<span class=c1># about. Here we use standardizing of the data, as it is often important</span>
<span class=c1># for decoding</span>
<span class=kn>from</span> <span class=nn>nilearn.input_data</span> <span class=kn>import</span> <span class=n>NiftiMasker</span>
<span class=n>masker</span> <span class=o>=</span> <span class=n>NiftiMasker</span><span class=p>(</span><span class=n>mask_img</span><span class=o>=</span><span class=n>mask_filename</span><span class=p>,</span> <span class=n>standardize</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>

<span class=c1># We give the masker a filename and retrieve a 2D array ready</span>
<span class=c1># for machine learning with scikit-learn</span>
<span class=n>fmri_masked</span> <span class=o>=</span> <span class=n>masker</span><span class=o>.</span><span class=n>fit_transform</span><span class=p>(</span><span class=n>fmri_filename</span><span class=p>)</span>
</pre></div></div><p>Note that you can call <cite>nifti_masker.transform(dataset.func[1])</cite> on new data to mask it in a similar way as the data that was used during the fit.</p></div><div class=section id=automatically-computing-a-mask><h4><span class=section-number>7.1.1.3.2. </span>Automatically computing a mask<a title="Permalink to this headline"class=headerlink href=#automatically-computing-a-mask>¶</a></h4><p>If your dataset does not provide a mask, the Nifti masker will compute one for you in the <cite>fit</cite> step. The generated mask can be accessed via the <cite>mask_img_</cite> attribute.</p><p>Detailed information on automatic mask computation can be found in: <a class="reference internal"href=../manipulating_images/input_output.html#extracting-data><span class="std std-ref">Input and output: neuroimaging data representation</span></a>.</p></div></div></div><div class=section id=applying-a-scikit-learn-machine-learning-method><h2><span class=section-number>7.1.2. </span>Applying a scikit-learn machine learning method<a title="Permalink to this headline"class=headerlink href=#applying-a-scikit-learn-machine-learning-method>¶</a></h2><p>Now that we have a 2D array, we can apply any estimator from the scikit-learn, using its <cite>fit</cite>, <cite>predict</cite> or <cite>transform</cite> methods.</p><p>Here, we use scikit-learn Support Vector Classification to learn how to predict the category of picture seen by the subject:</p><div class="highlight-python notranslate"><div class=highlight><pre><span></span><span class=n>svc</span><span class=o>.</span><span class=n>fit</span><span class=p>(</span><span class=n>fmri_masked</span><span class=p>,</span> <span class=n>conditions</span><span class=p>)</span>

<span class=c1>###########################################################################</span>
<span class=c1># We can then predict the labels from the data</span>
<span class=n>prediction</span> <span class=o>=</span> <span class=n>svc</span><span class=o>.</span><span class=n>predict</span><span class=p>(</span><span class=n>fmri_masked</span><span class=p>)</span>
<span class=nb>print</span><span class=p>(</span><span class=n>prediction</span><span class=p>)</span>

<span class=c1>###########################################################################</span>
</pre></div></div><p>We will not detail it here since there is a very good documentation about it in the <a class="reference external"href=http://scikit-learn.org/stable/modules/svm.html#classification>scikit-learn documentation</a></p></div><div class=section id=unmasking-inverse-transform><h2><span class=section-number>7.1.3. </span>Unmasking (inverse_transform)<a title="Permalink to this headline"class=headerlink href=#unmasking-inverse-transform>¶</a></h2><p>Unmasking data is as easy as masking it! This can be done by using method <cite>inverse_transform</cite> on your processed data. As you may want to unmask several kinds of data (not only the data that you previously masked but also the results of an algorithm), the masker is clever and can take data of dimension 1D (resp. 2D) to convert it back to 3D (resp. 4D).</p><div class="highlight-python notranslate"><div class=highlight><pre><span></span><span class=n>coef_img</span> <span class=o>=</span> <span class=n>masker</span><span class=o>.</span><span class=n>inverse_transform</span><span class=p>(</span><span class=n>coef_</span><span class=p>)</span>
<span class=nb>print</span><span class=p>(</span><span class=n>coef_img</span><span class=p>)</span>
</pre></div></div><p>Here we want to see the discriminating weights of some voxels.</p></div><div class=section id=visualizing-results><h2><span class=section-number>7.1.4. </span>Visualizing results<a title="Permalink to this headline"class=headerlink href=#visualizing-results>¶</a></h2><p>Again the visualization code is simple. We can use an fMRI slice as a background and plot the weights. Brighter points have a higher discriminating weight.</p><div class="highlight-python notranslate"><div class=highlight><pre><span></span><span class=kn>from</span> <span class=nn>nilearn.plotting</span> <span class=kn>import</span> <span class=n>plot_stat_map</span><span class=p>,</span> <span class=n>show</span>

<span class=n>plot_stat_map</span><span class=p>(</span><span class=n>coef_img</span><span class=p>,</span> <span class=n>bg_img</span><span class=o>=</span><span class=n>haxby_dataset</span><span class=o>.</span><span class=n>anat</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span>
              <span class=n>title</span><span class=o>=</span><span class=s2>"SVM weights"</span><span class=p>,</span> <span class=n>display_mode</span><span class=o>=</span><span class=s2>"yx"</span><span class=p>)</span>

<span class=n>show</span><span class=p>()</span>
</pre></div></div><div class="figure align-center"><a class="reference external image-reference"href=../auto_examples/plot_decoding_tutorial.html><img alt=../_images/sphx_glr_plot_haxby_anova_svm_001.png src=../_images/sphx_glr_plot_haxby_anova_svm_001.png style=width:365px;height:130px></a></div></div><div class=section id=going-further><h2><span class=section-number>7.1.5. </span>Going further<a title="Permalink to this headline"class=headerlink href=#going-further>¶</a></h2><p>The <a class="reference internal"href=../modules/generated/nilearn.input_data.NiftiMasker.html#nilearn.input_data.NiftiMasker title=nilearn.input_data.NiftiMasker><code class="xref py py-class docutils literal notranslate"><span class=pre>NiftiMasker</span></code></a> is a very powerful object and we have only scratched the surface of its possibilities. It is described in more details in the section <a class="reference internal"href=../manipulating_images/masker_objects.html#nifti-masker><span class="std std-ref">NiftiMasker: applying a mask to load time-series</span></a>. Also, simple functions that can be used to perform elementary operations such as masking or filtering are described in <a class="reference internal"href=../manipulating_images/manipulating_images.html#preprocessing-functions><span class="std std-ref">Functions for data preparation and image transformation</span></a>.</p></div></div><div class=clearer></div></div></div></div><div aria-label="main navigation"class=sphinxsidebar role=navigation><div class=sphinxsidebarwrapper><h4>Giving credit</h4><ul class=simple><li><p>Please consider <a href=../authors.html#citing>citing the papers</a>.</p></li></ul><h3><a href=../index.html>Table of Contents</a></h3><ul><li><a class="reference internal"href=#>7.1. Building your own neuroimaging machine-learning pipeline</a><ul><li><a class="reference internal"href=#data-loading-and-preprocessing>7.1.1. Data loading and preprocessing</a><ul><li><a class="reference internal"href=#downloading-the-data>7.1.1.1. Downloading the data</a></li><li><a class="reference internal"href=#loading-non-image-data-experiment-description>7.1.1.2. Loading non image data: experiment description</a></li><li><a class="reference internal"href=#masking-the-data-from-4d-image-to-2d-array>7.1.1.3. Masking the data: from 4D image to 2D array</a><ul><li><a class="reference internal"href=#applying-a-mask>7.1.1.3.1. Applying a mask</a></li><li><a class="reference internal"href=#automatically-computing-a-mask>7.1.1.3.2. Automatically computing a mask</a></li></ul></li></ul></li><li><a class="reference internal"href=#applying-a-scikit-learn-machine-learning-method>7.1.2. Applying a scikit-learn machine learning method</a></li><li><a class="reference internal"href=#unmasking-inverse-transform>7.1.3. Unmasking (inverse_transform)</a></li><li><a class="reference internal"href=#visualizing-results>7.1.4. Visualizing results</a></li><li><a class="reference internal"href=#going-further>7.1.5. Going further</a></li></ul></li></ul><h4>Previous topic</h4><p class=topless><a title="previous chapter"href=index.html><span class=section-number>7. </span>Advanced usage: manual pipelines and scaling up</a></p><h4>Next topic</h4><p class=topless><a title="next chapter"href=neurovault.html><span class=section-number>7.2. </span>Downloading statistical maps from the Neurovault repository</a></p><div id=searchbox role=search style=display:none><h3 id=searchlabel>Quick search</h3><div class=searchformwrapper><form action=../search.html class=search><input aria-labelledby=searchlabel name=q><input type=submit value=Go></form></div></div><script>$('#searchbox').show(0);</script></div></div><div class=clearer></div></div><div class=footer>© The nilearn developers 2010-2021. Created using <a href=http://sphinx.pocoo.org/>Sphinx</a> 4.0.2. <span style=padding-left:5ex> <a href=../_sources/building_blocks/manual_pipeline.rst.txt rel=nofollow>Show this page source</a> </span></div></body></html>