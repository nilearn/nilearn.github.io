<!doctypehtml><html lang=en><meta charset=utf-8><meta content=width=device-width,initial-scale=1.0 name=viewport><meta content="9.7.12. Computing a Region of Interest (ROI) mask manually"property=og:title><meta content=website property=og:type><meta content=https://nilearn.github.io/auto_examples/06_manipulating_images/plot_roi_extraction.html property=og:url><meta content=Nilearn property=og:site_name><meta content="This example shows manual steps to create and further modify an ROI spatial mask. They represent a means for “data folding”, i.e., extracting and then analyzing brain data from a subset of voxels r..."property=og:description><meta content=https://nilearn.github.io/_static/nilearn-logo.png property=og:image><meta content=Nilearn property=og:image:alt><title>Nilearn: Statistical Analysis for NeuroImaging in Python — Machine learning for NeuroImaging</title><link href=../../_static/pygments.css rel=stylesheet><link href=../../_static/nature.css rel=stylesheet><link href=../../_static/copybutton.css rel=stylesheet><link href=../../_static/sg_gallery.css rel=stylesheet><link href=../../_static/sg_gallery-binder.css rel=stylesheet><link href=../../_static/sg_gallery-dataframe.css rel=stylesheet><link href=../../_static/sg_gallery-rendered-html.css rel=stylesheet><script data-url_root=../../ id=documentation_options src=../../_static/documentation_options.js></script><script src=../../_static/jquery.js></script><script src=../../_static/underscore.js></script><script src=../../_static/doctools.js></script><script src=../../_static/clipboard.min.js></script><script src=../../_static/copybutton.js></script><link rel="shortcut icon"href=../../_static/favicon.ico><link href=../../search.html rel=search title=Search><link title="9.8.1. Multivariate decompositions: Independent component analysis of fMRI"href=../07_advanced/plot_ica_resting_state.html rel=next><link title="9.7.11. Visualization of affine resamplings"href=plot_affine_transformation.html rel=prev><meta content=True name=HandheldFriendly><meta content=width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0 name=viewport><meta content="nilearn, neuroimaging, python, neuroscience, machinelearning"name=keywords><script>function updateTopMenuPosition(height, width) {
    if($(window).scrollTop() > height && $(window).outerWidth() > 1024) {
        //begin to scroll
        $('.related-wrapper').css("z-index", 1000);
        $('.related-wrapper').css("position", "sticky");
        $('.related-wrapper').css("top", 0);
        $('.related-wrapper').css("width", width)
    } else {
        //lock it back into place
        $('.related-wrapper').css("position", "relative");
        $('.related-wrapper').css("top", 0)
    }
}

$(function() {
    var banner_height = $('#logo-banner').outerHeight();
    var banner_width = $('#logo-banner').outerWidth();
    var width = $('.related-wrapper').css("height", $('.related').outerHeight());

    updateTopMenuPosition(banner_height, width);

    $(window).scroll(function(event) {
        updateTopMenuPosition(banner_height, width)
    });

    $(window).resize(function(event) {
        var banner_width = $('#logo-banner').outerWidth();
        var menu_height = $('.related').outerHeight();
        $('.related').css("width", banner_width);
        $('.related-wrapper').css("height", menu_height);
        updateTopMenuPosition(banner_height, width)
    })
});</script><script>function updateSideBarPosition(top, offset, sections) {
    var pos = $(window).scrollTop();
    // Lock the table of content to a fixed position once we scroll enough
    var topShift = 2 * offset;
    if(pos > top + topShift + 1) {
        // begin to scroll with sticky menu bar
        var topShift = -topShift + 1;
        if ($(window).outerWidth() < 1024) {
            // compensate top menu that disappears
            topShift -= offset + 1
        }
        $('.sphinxsidebarwrapper').css("position", "fixed");
        $('.sphinxsidebarwrapper').css("top", topShift)
    }
    else {
        //lock it back into place
        $('.sphinxsidebarwrapper').css("position", "relative");
        $('.sphinxsidebarwrapper').css("top",0)
    }

    // Highlight the current section
    i = 0;
    current_section = 0;
    $('a.internal').removeClass('active');
    for(i in sections) {
        if(sections[i] > pos) {
            break
        }
        if($('a.internal[href$="' + i + '"]').is(':visible')){
            current_section = i
        }
    }
    $('a.internal[href$="' + current_section + '"]').addClass('active');
    $('a.internal[href$="' + current_section + '"]').parent().addClass('active')
}

$(function () {
    // Lock the table of content to a fixed position once we scroll enough
    var tocOffset = $('.related-wrapper').outerHeight();
    var marginTop = parseFloat($('.sphinxsidebarwrapper').css('margin-top').replace(/auto/, 0));
    var top = $('.sphinxsidebarwrapper').offset().top - marginTop;
    sections = {};
    url = document.URL.replace(/#.*$/, "");

    // Grab positions of our sections
    $('.headerlink').each(function(){
        sections[this.href.replace(url, '')] = $(this).offset().top - 50
    });

    updateSideBarPosition(top, tocOffset, sections);

    $(window).scroll(function(event) {
        updateSideBarPosition(top, tocOffset, sections)
    });

    $(window).resize(function(event) {
        tocOffset = $('.related-wrapper').outerHeight();
        updateSideBarPosition(top, tocOffset, sections)
    });
});</script><script>var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-41920728-1']);
        _gaq.push(['_trackPageview']);

        (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();</script><body><div id=logo-banner><div class=logo><a href=../../index.html> <img alt="Nilearn logo"border=0 src=../../_static/nilearn-logo.png> </a></div><div class=tags><ul><li><big><a href=../decoding/plot_haxby_anova_svm.html>SVM</a></big></li><li><small><a href=../../connectivity/parcellating.html>Ward clustering</a></small></li><li><a href=../../decoding/searchlight.html>Searchlight</a></li><li><big><a href=../../connectivity/resting_state_networks.html>ICA</a></big></li><li><a href=../../manipulating_images/data_preparation.html>Nifti IO</a></li><li><a href=../../modules/reference.html#module-nilearn.datasets>Datasets</a></li></ul></div><div class=banner><h1>Nilearn:</h1><h2>Statistics for NeuroImaging in Python</h2></div><div class=search_form><div class=gcse-search id=cse style=width:100%></div><script>(function() {
        var cx = '017289614950330089114:elrt9qoutrq';
        var gcse = document.createElement('script');
        gcse.type = 'text/javascript';
        gcse.async = true;
        gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
        var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(gcse, s);
      })();</script></div></div><div class=related-wrapper><div aria-label="related navigation"class=related role=navigation><h3>Navigation</h3><ul><li class=right style=margin-right:10px><a title="Python Module Index"href=../../py-modindex.html>modules</a></li><li class=right><a title="9.8.1. Multivariate decompositions: Independent component analysis of fMRI"accesskey=N href=../07_advanced/plot_ica_resting_state.html>next</a> |</li><li class=right><a title="9.7.11. Visualization of affine resamplings"accesskey=P href=plot_affine_transformation.html>previous</a> |</li><li><a href=../../index.html>Nilearn Home</a> | </li><li><a href=../../user_guide.html>User Guide</a> | </li><li><a href=../index.html>Examples</a> | </li><li><a href=../../modules/reference.html>Reference</a> | </li><li id=navbar-about><a href=../../authors.html>About</a>| </li><li><a href=../../glossary.html>Glossary</a>| </li><li><a href=../../bibliography.html>Bibliography</a>| </li><li id=navbar-ecosystem><a href=http://www.nipy.org/>Nipy ecosystem</a></li><li class="nav-item nav-item-1"><a href=../../user_guide.html>User guide: table of contents</a> »</li><li class="nav-item nav-item-2"><a accesskey=U href=../index.html><span class=section-number>9. </span>Nilearn usage examples</a> »</li><li class="nav-item nav-item-this"><a href>Nilearn: Statistical Analysis for NeuroImaging in Python</a></li></ul></div></div><div class=stable-banner>This is the <em>stable</em> documentation for the latest release of Nilearn, the current development version is available <a href=https://nilearn.github.io/dev/index.html>here</a>.</div><div class=document><div class=documentwrapper><div class=bodywrapper><div class=body role=main><div class="sphx-glr-download-link-note admonition note"><p class=admonition-title>Note</p><p>Click <a class="reference internal"href=#sphx-glr-download-auto-examples-06-manipulating-images-plot-roi-extraction-py><span class="std std-ref">here</span></a> to download the full example code or to run this example in your browser via Binder</p></div><div class="sphx-glr-example-title section"id=computing-a-region-of-interest-roi-mask-manually><span id=sphx-glr-auto-examples-06-manipulating-images-plot-roi-extraction-py></span><h1><span class=section-number>9.7.12. </span>Computing a Region of Interest (ROI) mask manually<a title="Permalink to this headline"class=headerlink href=#computing-a-region-of-interest-roi-mask-manually>¶</a></h1><p>This example shows manual steps to create and further modify an ROI spatial mask. They represent a means for “data folding”, i.e., extracting and then analyzing brain data from a subset of voxels rather than whole brain images. Example can also help alleviate curse of dimensionality (i.e., statistical problems that arise in the context of high-dimensional input variables).</p><p>We demonstrate how to compute a ROI mask using <strong>T-test</strong> and then how simple image operations can be used before and after computing ROI to improve the quality of the computed mask.</p><p>These chains of operations are easy to set up using Nilearn and Scipy Python libraries. Here we give clear guidelines about these steps, starting with pre-image operations to post-image operations. The main point is that visualization & results checking be possible at each step.</p><p>See also <a class="reference internal"href=plot_extract_rois_smith_atlas.html><span class=doc>Regions Extraction of Default Mode Networks using Smith Atlas</span></a> for automatic ROI extraction of brain connected networks given in 4D image.</p><div class="admonition note"><p class=admonition-title>Note</p><p>If you are using Nilearn with a version older than <code class="docutils literal notranslate"><span class=pre>0.9.0</span></code>, then you should either upgrade your version or import maskers from the <code class="docutils literal notranslate"><span class=pre>input_data</span></code> module instead of the <code class="docutils literal notranslate"><span class=pre>maskers</span></code> module.</p><p>That is, you should manually replace in the following example all occurrences of:</p><div class="highlight-python notranslate"><div class=highlight><pre><span></span><span class=kn>from</span> <span class=nn>nilearn.maskers</span> <span class=kn>import</span> <span class=n>NiftiMasker</span>
</pre></div></div><p>with:</p><div class="highlight-python notranslate"><div class=highlight><pre><span></span><span class=kn>from</span> <span class=nn>nilearn.input_data</span> <span class=kn>import</span> <span class=n>NiftiMasker</span>
</pre></div></div></div><p>Coordinates of the slice we are interested in each direction. We will be using them for visualization.</p><div class="highlight-default notranslate"><div class=highlight><pre><span></span><span class=c1># cut in x-direction</span>
<a class="sphx-glr-backref-module-builtins sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://docs.python.org/3.8/library/functions.html#int title=builtins.int><span class=n>sagittal</span></a> <span class=o>=</span> <span class=o>-</span><span class=mi>25</span>
<span class=c1># cut in y-direction</span>
<a class="sphx-glr-backref-module-builtins sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://docs.python.org/3.8/library/functions.html#int title=builtins.int><span class=n>coronal</span></a> <span class=o>=</span> <span class=o>-</span><span class=mi>37</span>
<span class=c1># cut in z-direction</span>
<a class="sphx-glr-backref-module-builtins sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://docs.python.org/3.8/library/functions.html#int title=builtins.int><span class=n>axial</span></a> <span class=o>=</span> <span class=o>-</span><span class=mi>6</span>

<span class=c1># coordinates displaying should be prepared as a list</span>
<a class="sphx-glr-backref-module-builtins sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://docs.python.org/3.8/library/stdtypes.html#list title=builtins.list><span class=n>cut_coords</span></a> <span class=o>=</span> <span class=p>[</span><a class="sphx-glr-backref-module-builtins sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://docs.python.org/3.8/library/functions.html#int title=builtins.int><span class=n>sagittal</span></a><span class=p>,</span> <a class="sphx-glr-backref-module-builtins sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://docs.python.org/3.8/library/functions.html#int title=builtins.int><span class=n>coronal</span></a><span class=p>,</span> <a class="sphx-glr-backref-module-builtins sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://docs.python.org/3.8/library/functions.html#int title=builtins.int><span class=n>axial</span></a><span class=p>]</span>
</pre></div></div><div class=section id=loading-the-data><h2><span class=section-number>9.7.12.1. </span>Loading the data<a title="Permalink to this headline"class=headerlink href=#loading-the-data>¶</a></h2><p>We rely on the Haxby datasets and its experiments to demonstrate the complete list of operations. Fetching datasets is easy, shipping with Nilearn using a function named as <cite>fetch_haxby</cite>. The data will then be automatically stored in a home directory with “nilearn_data” folder in your computer. From which, we process data using paths of the Nifti images.</p><div class="highlight-default notranslate"><div class=highlight><pre><span></span><span class=c1># We load data from nilearn by import datasets</span>
<span class=kn>from</span> <span class=nn>nilearn</span> <span class=kn>import</span> <span class=n>datasets</span>

<span class=c1># First, we fetch single subject specific data with haxby datasets: to have</span>
<span class=c1># anatomical image, EPI images and masks images</span>
<a class="sphx-glr-backref-module-sklearn-utils sphx-glr-backref-type-py-function"href=https://scikit-learn.org/stable/modules/generated/sklearn.utils.Bunch.html#sklearn.utils.Bunch title=sklearn.utils.Bunch><span class=n>haxby_dataset</span></a> <span class=o>=</span> <a class="sphx-glr-backref-module-nilearn-datasets sphx-glr-backref-type-py-function"href=../../modules/generated/nilearn.datasets.fetch_haxby.html#nilearn.datasets.fetch_haxby title=nilearn.datasets.fetch_haxby><span class=n>datasets</span><span class=o>.</span><span class=n>fetch_haxby</span></a><span class=p>()</span>

<span class=c1># print basic information on the dataset</span>
<span class=nb>print</span><span class=p>(</span><span class=s1>'First subject anatomical nifti image (3D) located is at: </span><span class=si>%s</span><span class=s1>'</span> <span class=o>%</span>
      <a class="sphx-glr-backref-module-builtins sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://docs.python.org/3.8/library/stdtypes.html#list title=builtins.list><span class=n>haxby_dataset</span><span class=o>.</span><span class=n>anat</span></a><span class=p>[</span><span class=mi>0</span><span class=p>])</span>
<span class=nb>print</span><span class=p>(</span><span class=s1>'First subject functional nifti image (4D) is located at: </span><span class=si>%s</span><span class=s1>'</span> <span class=o>%</span>
      <a class="sphx-glr-backref-module-builtins sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://docs.python.org/3.8/library/stdtypes.html#list title=builtins.list><span class=n>haxby_dataset</span><span class=o>.</span><span class=n>func</span></a><span class=p>[</span><span class=mi>0</span><span class=p>])</span>
<span class=nb>print</span><span class=p>(</span><span class=s1>'Labels of haxby dataset (text file) is located at: </span><span class=si>%s</span><span class=s1>'</span> <span class=o>%</span>
      <a class="sphx-glr-backref-module-builtins sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://docs.python.org/3.8/library/stdtypes.html#list title=builtins.list><span class=n>haxby_dataset</span><span class=o>.</span><span class=n>session_target</span></a><span class=p>[</span><span class=mi>0</span><span class=p>])</span>

<span class=c1># Second, load the labels stored in a text file into array using pandas</span>
<span class=kn>import</span> <span class=nn>pandas</span> <span class=k>as</span> <span class=nn>pd</span>

<a class="sphx-glr-backref-module-pandas-core-frame sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html#pandas.DataFrame title=pandas.core.frame.DataFrame><span class=n>session_target</span></a> <span class=o>=</span> <a class="sphx-glr-backref-module-pandas sphx-glr-backref-type-py-function"href=https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html#pandas.read_csv title=pandas.read_csv><span class=n>pd</span><span class=o>.</span><span class=n>read_csv</span></a><span class=p>(</span><a class="sphx-glr-backref-module-builtins sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://docs.python.org/3.8/library/stdtypes.html#list title=builtins.list><span class=n>haxby_dataset</span><span class=o>.</span><span class=n>session_target</span></a><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>sep</span><span class=o>=</span><span class=s2>" "</span><span class=p>)</span>
<span class=c1># Now, we have the labels and will be useful while computing student's t-test</span>
<a class="sphx-glr-backref-module-pandas-core-series sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.html#pandas.Series title=pandas.core.series.Series><span class=n>haxby_labels</span></a> <span class=o>=</span> <a class="sphx-glr-backref-module-pandas-core-frame sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html#pandas.DataFrame title=pandas.core.frame.DataFrame><span class=n>session_target</span></a><span class=p>[</span><span class=s1>'labels'</span><span class=p>]</span>
</pre></div></div><p class=sphx-glr-script-out>Out:</p><div class="sphx-glr-script-out highlight-none notranslate"><div class=highlight><pre><span></span>First subject anatomical nifti image (3D) located is at: /home/nicolas/nilearn_data/haxby2001/subj2/anat.nii.gz
First subject functional nifti image (4D) is located at: /home/nicolas/nilearn_data/haxby2001/subj2/bold.nii.gz
Labels of haxby dataset (text file) is located at: /home/nicolas/nilearn_data/haxby2001/subj2/labels.txt
</pre></div></div><p>We have the datasets in hand especially paths to the locations. Now, we do simple pre-processing step called as image smoothing on functional images and then build a statistical test on smoothed images.</p></div><div class=section id=build-a-statistical-test-to-find-voxels-of-interest><h2><span class=section-number>9.7.12.2. </span>Build a statistical test to find voxels of interest<a title="Permalink to this headline"class=headerlink href=#build-a-statistical-test-to-find-voxels-of-interest>¶</a></h2><p><strong>Smoothing</strong>: Functional MRI data have a low signal-to-noise ratio. When using methods that are not robust to noise, it is useful to apply a spatial filtering kernel on the data. Such data smoothing is usually applied using a Gaussian function with 4mm to 12mm <a class="reference internal"href=../../glossary.html#term-FWHM><span class="xref std std-term">full-width at half-maximum</span></a> (this is where the <a class="reference internal"href=../../glossary.html#term-FWHM><span class="xref std std-term">FWHM</span></a> comes from). The function <a class="reference internal"href=../../modules/generated/nilearn.image.smooth_img.html#nilearn.image.smooth_img title=nilearn.image.smooth_img><code class="xref py py-func docutils literal notranslate"><span class=pre>nilearn.image.smooth_img</span></code></a> accounts for potential anisotropy in the image affine (i.e., non-indentical <a class="reference internal"href=../../glossary.html#term-voxel><span class="xref std std-term">voxel</span></a> size in all the three dimensions). Analogous to the majority of nilearn functions, <a class="reference internal"href=../../modules/generated/nilearn.image.smooth_img.html#nilearn.image.smooth_img title=nilearn.image.smooth_img><code class="xref py py-func docutils literal notranslate"><span class=pre>nilearn.image.smooth_img</span></code></a> can also use file names as input parameters.</p><div class="highlight-default notranslate"><div class=highlight><pre><span></span><span class=c1># Smooth the data using image processing module from nilearn</span>
<span class=kn>from</span> <span class=nn>nilearn</span> <span class=kn>import</span> <span class=n>image</span>

<span class=c1># Functional data</span>
<a class="sphx-glr-backref-module-builtins sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://docs.python.org/3.8/library/stdtypes.html#str title=builtins.str><span class=n>fmri_filename</span></a> <span class=o>=</span> <a class="sphx-glr-backref-module-builtins sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://docs.python.org/3.8/library/stdtypes.html#list title=builtins.list><span class=n>haxby_dataset</span><span class=o>.</span><span class=n>func</span></a><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
<span class=c1># smoothing: first argument as functional data filename and smoothing value</span>
<span class=c1># (integer) in second argument. Output returns in Nifti image.</span>
<a class="sphx-glr-backref-module-nibabel-nifti1 sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://nipy.org/nibabel/reference/nibabel.nifti1.html#nibabel.nifti1.Nifti1Image title=nibabel.nifti1.Nifti1Image><span class=n>fmri_img</span></a> <span class=o>=</span> <a class="sphx-glr-backref-module-nilearn-image sphx-glr-backref-type-py-function"href=../../modules/generated/nilearn.image.smooth_img.html#nilearn.image.smooth_img title=nilearn.image.smooth_img><span class=n>image</span><span class=o>.</span><span class=n>smooth_img</span></a><span class=p>(</span><a class="sphx-glr-backref-module-builtins sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://docs.python.org/3.8/library/stdtypes.html#str title=builtins.str><span class=n>fmri_filename</span></a><span class=p>,</span> <span class=n>fwhm</span><span class=o>=</span><span class=mi>6</span><span class=p>)</span>

<span class=c1># Visualize the mean of the smoothed EPI image using plotting function</span>
<span class=c1># `plot_epi`</span>
<span class=kn>from</span> <span class=nn>nilearn.plotting</span> <span class=kn>import</span> <a class="sphx-glr-backref-module-nilearn-plotting sphx-glr-backref-type-py-function"href=../../modules/generated/nilearn.plotting.plot_epi.html#nilearn.plotting.plot_epi title=nilearn.plotting.plot_epi><span class=n>plot_epi</span></a>

<span class=c1># First, compute the voxel-wise mean of smooth EPI image (first argument) using</span>
<span class=c1># image processing module `image`</span>
<a class="sphx-glr-backref-module-nibabel-nifti1 sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://nipy.org/nibabel/reference/nibabel.nifti1.html#nibabel.nifti1.Nifti1Image title=nibabel.nifti1.Nifti1Image><span class=n>mean_img</span></a> <span class=o>=</span> <a class="sphx-glr-backref-module-nilearn-image sphx-glr-backref-type-py-function"href=../../modules/generated/nilearn.image.mean_img.html#nilearn.image.mean_img title=nilearn.image.mean_img><span class=n>image</span><span class=o>.</span><span class=n>mean_img</span></a><span class=p>(</span><a class="sphx-glr-backref-module-nibabel-nifti1 sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://nipy.org/nibabel/reference/nibabel.nifti1.html#nibabel.nifti1.Nifti1Image title=nibabel.nifti1.Nifti1Image><span class=n>fmri_img</span></a><span class=p>)</span>
<span class=c1># Second, we visualize the mean image with coordinates positioned manually</span>
<a class="sphx-glr-backref-module-nilearn-plotting sphx-glr-backref-type-py-function"href=../../modules/generated/nilearn.plotting.plot_epi.html#nilearn.plotting.plot_epi title=nilearn.plotting.plot_epi><span class=n>plot_epi</span></a><span class=p>(</span><a class="sphx-glr-backref-module-nibabel-nifti1 sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://nipy.org/nibabel/reference/nibabel.nifti1.html#nibabel.nifti1.Nifti1Image title=nibabel.nifti1.Nifti1Image><span class=n>mean_img</span></a><span class=p>,</span> <span class=n>title</span><span class=o>=</span><span class=s1>'Smoothed mean EPI'</span><span class=p>,</span> <a class="sphx-glr-backref-module-builtins sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://docs.python.org/3.8/library/stdtypes.html#list title=builtins.list><span class=n>cut_coords</span></a><span class=o>=</span><a class="sphx-glr-backref-module-builtins sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://docs.python.org/3.8/library/stdtypes.html#list title=builtins.list><span class=n>cut_coords</span></a><span class=p>)</span>
</pre></div></div><img alt="plot roi extraction"class=sphx-glr-single-img src=../../_images/sphx_glr_plot_roi_extraction_001.png srcset=../../_images/sphx_glr_plot_roi_extraction_001.png><p class=sphx-glr-script-out>Out:</p><div class="sphx-glr-script-out highlight-none notranslate"><div class=highlight><pre><span></span>&LTnilearn.plotting.displays._slicers.OrthoSlicer object at 0x7fa5416b0c40>
</pre></div></div><p>Given the smoothed functional data stored in variable ‘fmri_img’, we then select two features of interest with face and house experimental conditions. The method we will be using is a simple Student’s t-test. The below section gives us brief motivation example about why selecting features in high dimensional FMRI data setting.</p><p>Functional MRI data can be considered “high dimensional” given the p-versus-n ratio (e.g., p=~20,000-200,000 voxels for n=1000 samples or less). In this setting, machine-learning algorithms can perform poorly due to the so-called curse of dimensionality. However, simple means from the realms of classical statistics can help reducing the number of voxels.</p><div class="highlight-default notranslate"><div class=highlight><pre><span></span><span class=kn>from</span> <span class=nn>nilearn.image</span> <span class=kn>import</span> <a class="sphx-glr-backref-module-nilearn-image sphx-glr-backref-type-py-function"href=../../modules/generated/nilearn.image.get_data.html#nilearn.image.get_data title=nilearn.image.get_data><span class=n>get_data</span></a>

<a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray title=numpy.ndarray><span class=n>fmri_data</span></a> <span class=o>=</span> <a class="sphx-glr-backref-module-nilearn-image sphx-glr-backref-type-py-function"href=../../modules/generated/nilearn.image.get_data.html#nilearn.image.get_data title=nilearn.image.get_data><span class=n>get_data</span></a><span class=p>(</span><a class="sphx-glr-backref-module-nibabel-nifti1 sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://nipy.org/nibabel/reference/nibabel.nifti1.html#nibabel.nifti1.Nifti1Image title=nibabel.nifti1.Nifti1Image><span class=n>fmri_img</span></a><span class=p>)</span>
<span class=c1># number of voxels being x*y*z, samples in 4th dimension</span>
<a class="sphx-glr-backref-module-builtins sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://docs.python.org/3.8/library/stdtypes.html#tuple title=builtins.tuple><span class=n>fmri_data</span><span class=o>.</span><span class=n>shape</span></a>
</pre></div></div><p class=sphx-glr-script-out>Out:</p><div class="sphx-glr-script-out highlight-none notranslate"><div class=highlight><pre><span></span>(40, 64, 64, 1452)
</pre></div></div><p><strong>Selecting features using T-test</strong>: The Student’s t-test (<a class="reference external"title="(in SciPy v1.9.0.dev0+1861.1f2a6e8)"href=http://scipy.github.io/devdocs/reference/generated/scipy.stats.ttest_ind.html#scipy.stats.ttest_ind><code class="xref py py-func docutils literal notranslate"><span class=pre>scipy.stats.ttest_ind</span></code></a>) is an established method to determine whether two distributions have a different mean value. It can be used to compare voxel time-series from two different experimental conditions (e.g., when houses or faces are shown to individuals during brain scanning). If the time-series distribution is similar in the two conditions, then the voxel is not very interesting to discriminate the condition.</p><div class="highlight-default notranslate"><div class=highlight><pre><span></span><span class=kn>import</span> <span class=nn>numpy</span> <span class=k>as</span> <span class=nn>np</span>
<span class=kn>from</span> <span class=nn>scipy</span> <span class=kn>import</span> <span class=n>stats</span>

<span class=c1># This test returns p-values that represent probabilities that the two</span>
<span class=c1># time-series were not drawn from the same distribution. The lower the</span>
<span class=c1># p-value, the more discriminative is the voxel in distinguishing the two</span>
<span class=c1># conditions (faces and houses).</span>
<a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray title=numpy.ndarray><span class=n>_</span></a><span class=p>,</span> <a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray title=numpy.ndarray><span class=n>p_values</span></a> <span class=o>=</span> <a class="sphx-glr-backref-module-scipy-stats sphx-glr-backref-type-py-function"href=http://scipy.github.io/devdocs/reference/generated/scipy.stats.ttest_ind.html#scipy.stats.ttest_ind title=scipy.stats.ttest_ind><span class=n>stats</span><span class=o>.</span><span class=n>ttest_ind</span></a><span class=p>(</span><a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray title=numpy.ndarray><span class=n>fmri_data</span></a><span class=p>[</span><span class=o>...</span><span class=p>,</span> <a class="sphx-glr-backref-module-pandas-core-series sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.html#pandas.Series title=pandas.core.series.Series><span class=n>haxby_labels</span></a> <span class=o>==</span> <span class=s1>'face'</span><span class=p>],</span>
                              <a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray title=numpy.ndarray><span class=n>fmri_data</span></a><span class=p>[</span><span class=o>...</span><span class=p>,</span> <a class="sphx-glr-backref-module-pandas-core-series sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.html#pandas.Series title=pandas.core.series.Series><span class=n>haxby_labels</span></a> <span class=o>==</span> <span class=s1>'house'</span><span class=p>],</span>
                              <span class=n>axis</span><span class=o>=-</span><span class=mi>1</span><span class=p>)</span>

<span class=c1># Use a log scale for p-values</span>
<a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray title=numpy.ndarray><span class=n>log_p_values</span></a> <span class=o>=</span> <span class=o>-</span><a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://numpy.org/doc/stable/reference/generated/numpy.ufunc.html#numpy.ufunc title=numpy.ufunc><span class=n>np</span><span class=o>.</span><span class=n>log10</span></a><span class=p>(</span><a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray title=numpy.ndarray><span class=n>p_values</span></a><span class=p>)</span>
<span class=c1># NAN values to zero</span>
<a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray title=numpy.ndarray><span class=n>log_p_values</span></a><span class=p>[</span><a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://numpy.org/doc/stable/reference/generated/numpy.ufunc.html#numpy.ufunc title=numpy.ufunc><span class=n>np</span><span class=o>.</span><span class=n>isnan</span></a><span class=p>(</span><a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray title=numpy.ndarray><span class=n>log_p_values</span></a><span class=p>)]</span> <span class=o>=</span> <span class=mf>0.</span>
<a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray title=numpy.ndarray><span class=n>log_p_values</span></a><span class=p>[</span><a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray title=numpy.ndarray><span class=n>log_p_values</span></a> <span class=o>></span> <span class=mf>10.</span><span class=p>]</span> <span class=o>=</span> <span class=mf>10.</span>

<span class=c1># Visualize statistical p-values using plotting function `plot_stat_map`</span>
<span class=kn>from</span> <span class=nn>nilearn.plotting</span> <span class=kn>import</span> <a class="sphx-glr-backref-module-nilearn-plotting sphx-glr-backref-type-py-function"href=../../modules/generated/nilearn.plotting.plot_stat_map.html#nilearn.plotting.plot_stat_map title=nilearn.plotting.plot_stat_map><span class=n>plot_stat_map</span></a>

<span class=c1># Before visualizing, we transform the computed p-values to Nifti-like image</span>
<span class=c1># using function `new_img_like` from nilearn.</span>
<span class=kn>from</span> <span class=nn>nilearn.image</span> <span class=kn>import</span> <a class="sphx-glr-backref-module-nilearn-image sphx-glr-backref-type-py-function"href=../../modules/generated/nilearn.image.new_img_like.html#nilearn.image.new_img_like title=nilearn.image.new_img_like><span class=n>new_img_like</span></a>

<span class=c1># First argument being a reference image and second argument should be p-values</span>
<span class=c1># data to convert to a new image as output. This new image will have same header</span>
<span class=c1># information as reference image.</span>
<a class="sphx-glr-backref-module-nibabel-nifti1 sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://nipy.org/nibabel/reference/nibabel.nifti1.html#nibabel.nifti1.Nifti1Image title=nibabel.nifti1.Nifti1Image><span class=n>log_p_values_img</span></a> <span class=o>=</span> <a class="sphx-glr-backref-module-nilearn-image sphx-glr-backref-type-py-function"href=../../modules/generated/nilearn.image.new_img_like.html#nilearn.image.new_img_like title=nilearn.image.new_img_like><span class=n>new_img_like</span></a><span class=p>(</span><a class="sphx-glr-backref-module-nibabel-nifti1 sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://nipy.org/nibabel/reference/nibabel.nifti1.html#nibabel.nifti1.Nifti1Image title=nibabel.nifti1.Nifti1Image><span class=n>fmri_img</span></a><span class=p>,</span> <a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray title=numpy.ndarray><span class=n>log_p_values</span></a><span class=p>)</span>

<span class=c1># Now, we visualize log p-values image on functional mean image as background</span>
<span class=c1># with coordinates given manually and colorbar on the right side of plot (by</span>
<span class=c1># default colorbar=True)</span>
<a class="sphx-glr-backref-module-nilearn-plotting sphx-glr-backref-type-py-function"href=../../modules/generated/nilearn.plotting.plot_stat_map.html#nilearn.plotting.plot_stat_map title=nilearn.plotting.plot_stat_map><span class=n>plot_stat_map</span></a><span class=p>(</span><a class="sphx-glr-backref-module-nibabel-nifti1 sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://nipy.org/nibabel/reference/nibabel.nifti1.html#nibabel.nifti1.Nifti1Image title=nibabel.nifti1.Nifti1Image><span class=n>log_p_values_img</span></a><span class=p>,</span> <a class="sphx-glr-backref-module-nibabel-nifti1 sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://nipy.org/nibabel/reference/nibabel.nifti1.html#nibabel.nifti1.Nifti1Image title=nibabel.nifti1.Nifti1Image><span class=n>mean_img</span></a><span class=p>,</span>
              <span class=n>title</span><span class=o>=</span><span class=s2>"p-values"</span><span class=p>,</span> <a class="sphx-glr-backref-module-builtins sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://docs.python.org/3.8/library/stdtypes.html#list title=builtins.list><span class=n>cut_coords</span></a><span class=o>=</span><a class="sphx-glr-backref-module-builtins sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://docs.python.org/3.8/library/stdtypes.html#list title=builtins.list><span class=n>cut_coords</span></a><span class=p>)</span>
</pre></div></div><img alt="plot roi extraction"class=sphx-glr-single-img src=../../_images/sphx_glr_plot_roi_extraction_002.png srcset=../../_images/sphx_glr_plot_roi_extraction_002.png><p class=sphx-glr-script-out>Out:</p><div class="sphx-glr-script-out highlight-none notranslate"><div class=highlight><pre><span></span>&LTnilearn.plotting.displays._slicers.OrthoSlicer object at 0x7fa513ba3eb0>
</pre></div></div><p><strong>Selecting features using f_classif</strong>: Feature selection method is also available in the scikit-learn Python package, where it has been extended to several classes, using the <cite>sklearn.feature_selection.f_classif</cite> function.</p></div><div class=section id=build-a-mask-from-this-statistical-map-improving-the-quality-of-the-mask><h2><span class=section-number>9.7.12.3. </span>Build a mask from this statistical map (Improving the quality of the mask)<a title="Permalink to this headline"class=headerlink href=#build-a-mask-from-this-statistical-map-improving-the-quality-of-the-mask>¶</a></h2><p><strong>Thresholding</strong> - We build the t-map to have better representation of voxels of interest and voxels with lower p-values correspond to the most intense voxels. This can be done easily by applying a threshold to a t-map data in array.</p><div class="highlight-default notranslate"><div class=highlight><pre><span></span><span class=c1># Note that we use log p-values data; we force values below 5 to 0 by</span>
<span class=c1># thresholding.</span>
<a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray title=numpy.ndarray><span class=n>log_p_values</span></a><span class=p>[</span><a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray title=numpy.ndarray><span class=n>log_p_values</span></a> <span class=o><</span> <span class=mi>5</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>

<span class=c1># Visualize the reduced voxels of interest using statistical image plotting</span>
<span class=c1># function. As shown above, we first transform data in array to Nifti image.</span>
<a class="sphx-glr-backref-module-nibabel-nifti1 sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://nipy.org/nibabel/reference/nibabel.nifti1.html#nibabel.nifti1.Nifti1Image title=nibabel.nifti1.Nifti1Image><span class=n>log_p_values_img</span></a> <span class=o>=</span> <a class="sphx-glr-backref-module-nilearn-image sphx-glr-backref-type-py-function"href=../../modules/generated/nilearn.image.new_img_like.html#nilearn.image.new_img_like title=nilearn.image.new_img_like><span class=n>new_img_like</span></a><span class=p>(</span><a class="sphx-glr-backref-module-nibabel-nifti1 sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://nipy.org/nibabel/reference/nibabel.nifti1.html#nibabel.nifti1.Nifti1Image title=nibabel.nifti1.Nifti1Image><span class=n>fmri_img</span></a><span class=p>,</span> <a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray title=numpy.ndarray><span class=n>log_p_values</span></a><span class=p>)</span>

<span class=c1># Now, visualizing the created log p-values to image without colorbar and</span>
<span class=c1># without Left - 'L', Right - 'R' annotation</span>
<a class="sphx-glr-backref-module-nilearn-plotting sphx-glr-backref-type-py-function"href=../../modules/generated/nilearn.plotting.plot_stat_map.html#nilearn.plotting.plot_stat_map title=nilearn.plotting.plot_stat_map><span class=n>plot_stat_map</span></a><span class=p>(</span><a class="sphx-glr-backref-module-nibabel-nifti1 sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://nipy.org/nibabel/reference/nibabel.nifti1.html#nibabel.nifti1.Nifti1Image title=nibabel.nifti1.Nifti1Image><span class=n>log_p_values_img</span></a><span class=p>,</span> <a class="sphx-glr-backref-module-nibabel-nifti1 sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://nipy.org/nibabel/reference/nibabel.nifti1.html#nibabel.nifti1.Nifti1Image title=nibabel.nifti1.Nifti1Image><span class=n>mean_img</span></a><span class=p>,</span>
              <span class=n>title</span><span class=o>=</span><span class=s1>'Thresholded p-values'</span><span class=p>,</span> <span class=n>annotate</span><span class=o>=</span><span class=kc>False</span><span class=p>,</span>
              <span class=n>colorbar</span><span class=o>=</span><span class=kc>False</span><span class=p>,</span> <a class="sphx-glr-backref-module-builtins sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://docs.python.org/3.8/library/stdtypes.html#list title=builtins.list><span class=n>cut_coords</span></a><span class=o>=</span><a class="sphx-glr-backref-module-builtins sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://docs.python.org/3.8/library/stdtypes.html#list title=builtins.list><span class=n>cut_coords</span></a><span class=p>)</span>
</pre></div></div><img alt="plot roi extraction"class=sphx-glr-single-img src=../../_images/sphx_glr_plot_roi_extraction_003.png srcset=../../_images/sphx_glr_plot_roi_extraction_003.png><p class=sphx-glr-script-out>Out:</p><div class="sphx-glr-script-out highlight-none notranslate"><div class=highlight><pre><span></span>&LTnilearn.plotting.displays._slicers.OrthoSlicer object at 0x7fa4fc558eb0>
</pre></div></div><p>We can post-process the results obtained with simple operations such as mask intersection and dilation to regularize the mask definition. The idea of using these operations are to have more compact or sparser blobs.</p><p><strong>Binarization</strong> and <strong>Intersection</strong> with Ventral Temporal (VT) mask - We now want to restrict our investigation to the VT area. The corresponding spatial mask is provided in haxby_dataset.mask_vt. We want to compute the intersection of this provided mask with our self-computed mask.</p><div class="highlight-default notranslate"><div class=highlight><pre><span></span><span class=c1># self-computed mask</span>
<a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray title=numpy.ndarray><span class=n>bin_p_values</span></a> <span class=o>=</span> <span class=p>(</span><a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray title=numpy.ndarray><span class=n>log_p_values</span></a> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
<span class=c1># VT mask</span>
<a class="sphx-glr-backref-module-builtins sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://docs.python.org/3.8/library/stdtypes.html#str title=builtins.str><span class=n>mask_vt_filename</span></a> <span class=o>=</span> <a class="sphx-glr-backref-module-builtins sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://docs.python.org/3.8/library/stdtypes.html#list title=builtins.list><span class=n>haxby_dataset</span><span class=o>.</span><span class=n>mask_vt</span></a><span class=p>[</span><span class=mi>0</span><span class=p>]</span>

<span class=c1># The first step is to load VT mask and same time convert data type</span>
<span class=c1># numbers to boolean type</span>
<span class=kn>from</span> <span class=nn>nilearn.image</span> <span class=kn>import</span> <a class="sphx-glr-backref-module-nilearn-image sphx-glr-backref-type-py-function"href=../../modules/generated/nilearn.image.load_img.html#nilearn.image.load_img title=nilearn.image.load_img><span class=n>load_img</span></a>

<a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray title=numpy.ndarray><span class=n>vt</span></a> <span class=o>=</span> <a class="sphx-glr-backref-module-nilearn-image sphx-glr-backref-type-py-function"href=../../modules/generated/nilearn.image.get_data.html#nilearn.image.get_data title=nilearn.image.get_data><span class=n>get_data</span></a><span class=p>(</span><a class="sphx-glr-backref-module-nilearn-image sphx-glr-backref-type-py-function"href=../../modules/generated/nilearn.image.load_img.html#nilearn.image.load_img title=nilearn.image.load_img><span class=n>load_img</span></a><span class=p>(</span><a class="sphx-glr-backref-module-builtins sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://docs.python.org/3.8/library/stdtypes.html#str title=builtins.str><span class=n>mask_vt_filename</span></a><span class=p>))</span><span class=o>.</span><span class=n>astype</span><span class=p>(</span><span class=nb>bool</span><span class=p>)</span>

<span class=c1># We can then use a logical "and" operation - numpy.logical_and - to keep only</span>
<span class=c1># voxels that have been selected in both masks. In neuroimaging jargon, this</span>
<span class=c1># is called an "AND conjunction". We use already imported numpy as np</span>
<a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray title=numpy.ndarray><span class=n>bin_p_values_and_vt</span></a> <span class=o>=</span> <a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://numpy.org/doc/stable/reference/generated/numpy.ufunc.html#numpy.ufunc title=numpy.ufunc><span class=n>np</span><span class=o>.</span><span class=n>logical_and</span></a><span class=p>(</span><a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray title=numpy.ndarray><span class=n>bin_p_values</span></a><span class=p>,</span> <a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray title=numpy.ndarray><span class=n>vt</span></a><span class=p>)</span>

<span class=c1># Visualizing the mask intersection results using plotting function `plot_roi`,</span>
<span class=c1># a function which can be used for visualizing target specific voxels.</span>
<span class=kn>from</span> <span class=nn>nilearn.plotting</span> <span class=kn>import</span> <a class="sphx-glr-backref-module-nilearn-plotting sphx-glr-backref-type-py-function"href=../../modules/generated/nilearn.plotting.plot_roi.html#nilearn.plotting.plot_roi title=nilearn.plotting.plot_roi><span class=n>plot_roi</span></a><span class=p>,</span> <a class="sphx-glr-backref-module-nilearn-plotting sphx-glr-backref-type-py-function"href=../../modules/generated/nilearn.plotting.show.html#nilearn.plotting.show title=nilearn.plotting.show><span class=n>show</span></a>

<span class=c1># First, we create new image type of binarized and intersected mask (second</span>
<span class=c1># argument) and use this created Nifti image type in visualization. Binarized</span>
<span class=c1># values in data type boolean should be converted to int data type at the same</span>
<span class=c1># time. Otherwise, an error will be raised</span>
<a class="sphx-glr-backref-module-nibabel-nifti1 sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://nipy.org/nibabel/reference/nibabel.nifti1.html#nibabel.nifti1.Nifti1Image title=nibabel.nifti1.Nifti1Image><span class=n>bin_p_values_and_vt_img</span></a> <span class=o>=</span> <a class="sphx-glr-backref-module-nilearn-image sphx-glr-backref-type-py-function"href=../../modules/generated/nilearn.image.new_img_like.html#nilearn.image.new_img_like title=nilearn.image.new_img_like><span class=n>new_img_like</span></a><span class=p>(</span><a class="sphx-glr-backref-module-nibabel-nifti1 sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://nipy.org/nibabel/reference/nibabel.nifti1.html#nibabel.nifti1.Nifti1Image title=nibabel.nifti1.Nifti1Image><span class=n>fmri_img</span></a><span class=p>,</span>
                                       <a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray title=numpy.ndarray><span class=n>bin_p_values_and_vt</span></a><span class=o>.</span><span class=n>astype</span><span class=p>(</span><span class=nb>int</span><span class=p>))</span>
<span class=c1># Visualizing goes here with background as computed mean of functional images</span>
<a class="sphx-glr-backref-module-nilearn-plotting sphx-glr-backref-type-py-function"href=../../modules/generated/nilearn.plotting.plot_roi.html#nilearn.plotting.plot_roi title=nilearn.plotting.plot_roi><span class=n>plot_roi</span></a><span class=p>(</span><a class="sphx-glr-backref-module-nibabel-nifti1 sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://nipy.org/nibabel/reference/nibabel.nifti1.html#nibabel.nifti1.Nifti1Image title=nibabel.nifti1.Nifti1Image><span class=n>bin_p_values_and_vt_img</span></a><span class=p>,</span> <a class="sphx-glr-backref-module-nibabel-nifti1 sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://nipy.org/nibabel/reference/nibabel.nifti1.html#nibabel.nifti1.Nifti1Image title=nibabel.nifti1.Nifti1Image><span class=n>mean_img</span></a><span class=p>,</span> <a class="sphx-glr-backref-module-builtins sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://docs.python.org/3.8/library/stdtypes.html#list title=builtins.list><span class=n>cut_coords</span></a><span class=o>=</span><a class="sphx-glr-backref-module-builtins sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://docs.python.org/3.8/library/stdtypes.html#list title=builtins.list><span class=n>cut_coords</span></a><span class=p>,</span>
         <span class=n>title</span><span class=o>=</span><span class=s1>'Intersection with ventral temporal mask'</span><span class=p>)</span>
</pre></div></div><img alt="plot roi extraction"class=sphx-glr-single-img src=../../_images/sphx_glr_plot_roi_extraction_004.png srcset=../../_images/sphx_glr_plot_roi_extraction_004.png><p class=sphx-glr-script-out>Out:</p><div class="sphx-glr-script-out highlight-none notranslate"><div class=highlight><pre><span></span>&LTnilearn.plotting.displays._slicers.OrthoSlicer object at 0x7fa512afa610>
</pre></div></div><p><strong>Dilation</strong> - Thresholded functional brain images often contain scattered voxels across the brain. To consolidate such brain images towards more compact shapes, we use a <a class="reference external"href=http://en.wikipedia.org/wiki/Dilation_(morphology)>morphological dilation</a>. This is a common step to be sure not to forget voxels located on the edge of a ROI. In other words, such operations can fill “holes” in masked voxel representations.</p><div class="highlight-default notranslate"><div class=highlight><pre><span></span><span class=c1># We use ndimage function from scipy Python library for mask dilation</span>
<span class=kn>from</span> <span class=nn>scipy</span> <span class=kn>import</span> <span class=n>ndimage</span>

<span class=c1># Input here is a binarized and intersected mask data from previous section</span>
<a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray title=numpy.ndarray><span class=n>dil_bin_p_values_and_vt</span></a> <span class=o>=</span> <a class="sphx-glr-backref-module-scipy-ndimage sphx-glr-backref-type-py-function"href=http://scipy.github.io/devdocs/reference/generated/scipy.ndimage.binary_dilation.html#scipy.ndimage.binary_dilation title=scipy.ndimage.binary_dilation><span class=n>ndimage</span><span class=o>.</span><span class=n>binary_dilation</span></a><span class=p>(</span><a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray title=numpy.ndarray><span class=n>bin_p_values_and_vt</span></a><span class=p>)</span>

<span class=c1># Now, we visualize the same using `plot_roi` with data being converted to Nifti</span>
<span class=c1># image. In all new image like, reference image is the same but second argument</span>
<span class=c1># varies with data specific</span>
<a class="sphx-glr-backref-module-nibabel-nifti1 sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://nipy.org/nibabel/reference/nibabel.nifti1.html#nibabel.nifti1.Nifti1Image title=nibabel.nifti1.Nifti1Image><span class=n>dil_bin_p_values_and_vt_img</span></a> <span class=o>=</span> <a class="sphx-glr-backref-module-nilearn-image sphx-glr-backref-type-py-function"href=../../modules/generated/nilearn.image.new_img_like.html#nilearn.image.new_img_like title=nilearn.image.new_img_like><span class=n>new_img_like</span></a><span class=p>(</span>
    <a class="sphx-glr-backref-module-nibabel-nifti1 sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://nipy.org/nibabel/reference/nibabel.nifti1.html#nibabel.nifti1.Nifti1Image title=nibabel.nifti1.Nifti1Image><span class=n>fmri_img</span></a><span class=p>,</span>
    <a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray title=numpy.ndarray><span class=n>dil_bin_p_values_and_vt</span></a><span class=o>.</span><span class=n>astype</span><span class=p>(</span><span class=nb>int</span><span class=p>))</span>
<span class=c1># Visualization goes here without 'L', 'R' annotation and coordinates being the</span>
<span class=c1># same</span>
<a class="sphx-glr-backref-module-nilearn-plotting sphx-glr-backref-type-py-function"href=../../modules/generated/nilearn.plotting.plot_roi.html#nilearn.plotting.plot_roi title=nilearn.plotting.plot_roi><span class=n>plot_roi</span></a><span class=p>(</span><a class="sphx-glr-backref-module-nibabel-nifti1 sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://nipy.org/nibabel/reference/nibabel.nifti1.html#nibabel.nifti1.Nifti1Image title=nibabel.nifti1.Nifti1Image><span class=n>dil_bin_p_values_and_vt_img</span></a><span class=p>,</span> <a class="sphx-glr-backref-module-nibabel-nifti1 sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://nipy.org/nibabel/reference/nibabel.nifti1.html#nibabel.nifti1.Nifti1Image title=nibabel.nifti1.Nifti1Image><span class=n>mean_img</span></a><span class=p>,</span>
         <span class=n>title</span><span class=o>=</span><span class=s1>'Dilated mask'</span><span class=p>,</span> <a class="sphx-glr-backref-module-builtins sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://docs.python.org/3.8/library/stdtypes.html#list title=builtins.list><span class=n>cut_coords</span></a><span class=o>=</span><a class="sphx-glr-backref-module-builtins sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://docs.python.org/3.8/library/stdtypes.html#list title=builtins.list><span class=n>cut_coords</span></a><span class=p>,</span>
         <span class=n>annotate</span><span class=o>=</span><span class=kc>False</span><span class=p>)</span>
</pre></div></div><img alt="plot roi extraction"class=sphx-glr-single-img src=../../_images/sphx_glr_plot_roi_extraction_005.png srcset=../../_images/sphx_glr_plot_roi_extraction_005.png><p class=sphx-glr-script-out>Out:</p><div class="sphx-glr-script-out highlight-none notranslate"><div class=highlight><pre><span></span>&LTnilearn.plotting.displays._slicers.OrthoSlicer object at 0x7fa50d5f5b50>
</pre></div></div><p>Finally, we end with splitting the connected ROIs to two hemispheres into two separate regions (ROIs). The function <cite>scipy.ndimage.label</cite> from the scipy Python library.</p><p><strong>Identification of connected components</strong> - The function <a class="reference external"title="(in SciPy v1.9.0.dev0+1861.1f2a6e8)"href=http://scipy.github.io/devdocs/reference/generated/scipy.ndimage.label.html#scipy.ndimage.label><code class="xref py py-func docutils literal notranslate"><span class=pre>scipy.ndimage.label</span></code></a> from the scipy Python library identifies immediately neighboring voxels in our voxels mask. It assigns a separate integer label to each one of them.</p><div class="highlight-default notranslate"><div class=highlight><pre><span></span><a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray title=numpy.ndarray><span class=n>labels</span></a><span class=p>,</span> <a class="sphx-glr-backref-module-builtins sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://docs.python.org/3.8/library/functions.html#int title=builtins.int><span class=n>n_labels</span></a> <span class=o>=</span> <a class="sphx-glr-backref-module-scipy-ndimage sphx-glr-backref-type-py-function"href=http://scipy.github.io/devdocs/reference/generated/scipy.ndimage.label.html#scipy.ndimage.label title=scipy.ndimage.label><span class=n>ndimage</span><span class=o>.</span><span class=n>label</span></a><span class=p>(</span><a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray title=numpy.ndarray><span class=n>dil_bin_p_values_and_vt</span></a><span class=p>)</span>
<span class=c1># we take first roi data with labels assigned as integer 1</span>
<a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray title=numpy.ndarray><span class=n>first_roi_data</span></a> <span class=o>=</span> <span class=p>(</span><a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray title=numpy.ndarray><span class=n>labels</span></a> <span class=o>==</span> <span class=mi>5</span><span class=p>)</span><span class=o>.</span><span class=n>astype</span><span class=p>(</span><span class=nb>int</span><span class=p>)</span>
<span class=c1># Similarly, second roi data is assigned as integer 2</span>
<a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray title=numpy.ndarray><span class=n>second_roi_data</span></a> <span class=o>=</span> <span class=p>(</span><a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray title=numpy.ndarray><span class=n>labels</span></a> <span class=o>==</span> <span class=mi>3</span><span class=p>)</span><span class=o>.</span><span class=n>astype</span><span class=p>(</span><span class=nb>int</span><span class=p>)</span>
<span class=c1># Visualizing the connected components</span>
<span class=c1># First, we create a Nifti image type from first roi data in a array</span>
<a class="sphx-glr-backref-module-nibabel-nifti1 sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://nipy.org/nibabel/reference/nibabel.nifti1.html#nibabel.nifti1.Nifti1Image title=nibabel.nifti1.Nifti1Image><span class=n>first_roi_img</span></a> <span class=o>=</span> <a class="sphx-glr-backref-module-nilearn-image sphx-glr-backref-type-py-function"href=../../modules/generated/nilearn.image.new_img_like.html#nilearn.image.new_img_like title=nilearn.image.new_img_like><span class=n>new_img_like</span></a><span class=p>(</span><a class="sphx-glr-backref-module-nibabel-nifti1 sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://nipy.org/nibabel/reference/nibabel.nifti1.html#nibabel.nifti1.Nifti1Image title=nibabel.nifti1.Nifti1Image><span class=n>fmri_img</span></a><span class=p>,</span> <a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray title=numpy.ndarray><span class=n>first_roi_data</span></a><span class=p>)</span>
<span class=c1># Then, visualize the same created Nifti image in first argument and mean of</span>
<span class=c1># functional images as background (second argument), cut_coords is default now</span>
<span class=c1># and coordinates are selected automatically pointed exactly on the roi data</span>
<a class="sphx-glr-backref-module-nilearn-plotting sphx-glr-backref-type-py-function"href=../../modules/generated/nilearn.plotting.plot_roi.html#nilearn.plotting.plot_roi title=nilearn.plotting.plot_roi><span class=n>plot_roi</span></a><span class=p>(</span><a class="sphx-glr-backref-module-nibabel-nifti1 sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://nipy.org/nibabel/reference/nibabel.nifti1.html#nibabel.nifti1.Nifti1Image title=nibabel.nifti1.Nifti1Image><span class=n>first_roi_img</span></a><span class=p>,</span> <a class="sphx-glr-backref-module-nibabel-nifti1 sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://nipy.org/nibabel/reference/nibabel.nifti1.html#nibabel.nifti1.Nifti1Image title=nibabel.nifti1.Nifti1Image><span class=n>mean_img</span></a><span class=p>,</span> <span class=n>title</span><span class=o>=</span><span class=s1>'Connected components: first ROI'</span><span class=p>)</span>
<span class=c1># we do the same for second roi data</span>
<a class="sphx-glr-backref-module-nibabel-nifti1 sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://nipy.org/nibabel/reference/nibabel.nifti1.html#nibabel.nifti1.Nifti1Image title=nibabel.nifti1.Nifti1Image><span class=n>second_roi_img</span></a> <span class=o>=</span> <a class="sphx-glr-backref-module-nilearn-image sphx-glr-backref-type-py-function"href=../../modules/generated/nilearn.image.new_img_like.html#nilearn.image.new_img_like title=nilearn.image.new_img_like><span class=n>new_img_like</span></a><span class=p>(</span><a class="sphx-glr-backref-module-nibabel-nifti1 sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://nipy.org/nibabel/reference/nibabel.nifti1.html#nibabel.nifti1.Nifti1Image title=nibabel.nifti1.Nifti1Image><span class=n>fmri_img</span></a><span class=p>,</span> <a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray title=numpy.ndarray><span class=n>second_roi_data</span></a><span class=p>)</span>
<span class=c1># Visualization goes here with second roi image and cut_coords are default with</span>
<span class=c1># coordinates selected automatically pointed on the data</span>
<a class="sphx-glr-backref-module-nilearn-plotting sphx-glr-backref-type-py-function"href=../../modules/generated/nilearn.plotting.plot_roi.html#nilearn.plotting.plot_roi title=nilearn.plotting.plot_roi><span class=n>plot_roi</span></a><span class=p>(</span><a class="sphx-glr-backref-module-nibabel-nifti1 sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://nipy.org/nibabel/reference/nibabel.nifti1.html#nibabel.nifti1.Nifti1Image title=nibabel.nifti1.Nifti1Image><span class=n>second_roi_img</span></a><span class=p>,</span> <a class="sphx-glr-backref-module-nibabel-nifti1 sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://nipy.org/nibabel/reference/nibabel.nifti1.html#nibabel.nifti1.Nifti1Image title=nibabel.nifti1.Nifti1Image><span class=n>mean_img</span></a><span class=p>,</span> <span class=n>title</span><span class=o>=</span><span class=s1>'Connected components: second ROI'</span><span class=p>)</span>
</pre></div></div><ul class=sphx-glr-horizontal><li><img alt="plot roi extraction"class=sphx-glr-multi-img src=../../_images/sphx_glr_plot_roi_extraction_006.png srcset=../../_images/sphx_glr_plot_roi_extraction_006.png></li><li><img alt="plot roi extraction"class=sphx-glr-multi-img src=../../_images/sphx_glr_plot_roi_extraction_007.png srcset=../../_images/sphx_glr_plot_roi_extraction_007.png></li></ul><p class=sphx-glr-script-out>Out:</p><div class="sphx-glr-script-out highlight-none notranslate"><div class=highlight><pre><span></span>&LTnilearn.plotting.displays._slicers.OrthoSlicer object at 0x7fa5082d62e0>
</pre></div></div><p>Use the new ROIs, to extract data maps in both ROIs</p><div class="highlight-default notranslate"><div class=highlight><pre><span></span><span class=c1># We extract data from ROIs using nilearn's NiftiLabelsMasker</span>
<span class=kn>from</span> <span class=nn>nilearn.maskers</span> <span class=kn>import</span> <a class="sphx-glr-backref-module-nilearn-maskers sphx-glr-backref-type-py-class"href=../../modules/generated/nilearn.maskers.NiftiLabelsMasker.html#nilearn.maskers.NiftiLabelsMasker title=nilearn.maskers.NiftiLabelsMasker><span class=n>NiftiLabelsMasker</span></a>

<span class=c1># Before data extraction, we convert an array labels to Nifti like image. All</span>
<span class=c1># inputs to NiftiLabelsMasker must be Nifti-like images or filename to Nifti</span>
<span class=c1># images. We use the same reference image as used above in previous sections</span>
<a class="sphx-glr-backref-module-nibabel-nifti1 sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://nipy.org/nibabel/reference/nibabel.nifti1.html#nibabel.nifti1.Nifti1Image title=nibabel.nifti1.Nifti1Image><span class=n>labels_img</span></a> <span class=o>=</span> <a class="sphx-glr-backref-module-nilearn-image sphx-glr-backref-type-py-function"href=../../modules/generated/nilearn.image.new_img_like.html#nilearn.image.new_img_like title=nilearn.image.new_img_like><span class=n>new_img_like</span></a><span class=p>(</span><a class="sphx-glr-backref-module-nibabel-nifti1 sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://nipy.org/nibabel/reference/nibabel.nifti1.html#nibabel.nifti1.Nifti1Image title=nibabel.nifti1.Nifti1Image><span class=n>fmri_img</span></a><span class=p>,</span> <a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray title=numpy.ndarray><span class=n>labels</span></a><span class=p>)</span>
<span class=c1># First, initialize masker with parameters suited for data extraction using</span>
<span class=c1># labels as input image, resampling_target is None as affine, shape/size is same</span>
<span class=c1># for all the data used here, time series signal processing parameters</span>
<span class=c1># standardize and detrend are set to False</span>
<a class="sphx-glr-backref-module-nilearn-maskers sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=../../modules/generated/nilearn.maskers.NiftiLabelsMasker.html#nilearn.maskers.NiftiLabelsMasker title=nilearn.maskers.NiftiLabelsMasker><span class=n>masker</span></a> <span class=o>=</span> <a class="sphx-glr-backref-module-nilearn-maskers sphx-glr-backref-type-py-class"href=../../modules/generated/nilearn.maskers.NiftiLabelsMasker.html#nilearn.maskers.NiftiLabelsMasker title=nilearn.maskers.NiftiLabelsMasker><span class=n>NiftiLabelsMasker</span></a><span class=p>(</span><a class="sphx-glr-backref-module-nibabel-nifti1 sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://nipy.org/nibabel/reference/nibabel.nifti1.html#nibabel.nifti1.Nifti1Image title=nibabel.nifti1.Nifti1Image><span class=n>labels_img</span></a><span class=p>,</span> <span class=n>resampling_target</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span>
                           <span class=n>standardize</span><span class=o>=</span><span class=kc>False</span><span class=p>,</span> <span class=n>detrend</span><span class=o>=</span><span class=kc>False</span><span class=p>)</span>
<span class=c1># After initialization of masker object, we call fit() for preparing labels_img</span>
<span class=c1># data according to given parameters</span>
<a class="sphx-glr-backref-module-nilearn-maskers sphx-glr-backref-type-py-method"href=../../modules/generated/nilearn.maskers.NiftiLabelsMasker.html#nilearn.maskers.NiftiLabelsMasker.fit title=nilearn.maskers.NiftiLabelsMasker.fit><span class=n>masker</span><span class=o>.</span><span class=n>fit</span></a><span class=p>()</span>
<span class=c1># Preparing for data extraction: setting number of conditions, size, etc from</span>
<span class=c1># haxby dataset</span>
<a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray title=numpy.ndarray><span class=n>condition_names</span></a> <span class=o>=</span> <a class="sphx-glr-backref-module-pandas sphx-glr-backref-type-py-method"href=https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.unique.html#pandas.Series.unique title=pandas.Series.unique><span class=n>haxby_labels</span><span class=o>.</span><span class=n>unique</span></a><span class=p>()</span>
<a class="sphx-glr-backref-module-builtins sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://docs.python.org/3.8/library/functions.html#int title=builtins.int><span class=n>n_cond_img</span></a> <span class=o>=</span> <a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray title=numpy.ndarray><span class=n>fmri_data</span></a><span class=p>[</span><span class=o>...</span><span class=p>,</span> <a class="sphx-glr-backref-module-pandas-core-series sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.html#pandas.Series title=pandas.core.series.Series><span class=n>haxby_labels</span></a> <span class=o>==</span> <span class=s1>'house'</span><span class=p>]</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
<a class="sphx-glr-backref-module-builtins sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://docs.python.org/3.8/library/functions.html#int title=builtins.int><span class=n>n_conds</span></a> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray title=numpy.ndarray><span class=n>condition_names</span></a><span class=p>)</span>

<a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray title=numpy.ndarray><span class=n>X1</span></a><span class=p>,</span> <a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray title=numpy.ndarray><span class=n>X2</span></a> <span class=o>=</span> <a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-function"href=https://numpy.org/doc/stable/reference/generated/numpy.zeros.html#numpy.zeros title=numpy.zeros><span class=n>np</span><span class=o>.</span><span class=n>zeros</span></a><span class=p>((</span><a class="sphx-glr-backref-module-builtins sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://docs.python.org/3.8/library/functions.html#int title=builtins.int><span class=n>n_cond_img</span></a><span class=p>,</span> <a class="sphx-glr-backref-module-builtins sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://docs.python.org/3.8/library/functions.html#int title=builtins.int><span class=n>n_conds</span></a><span class=p>)),</span> <a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-function"href=https://numpy.org/doc/stable/reference/generated/numpy.zeros.html#numpy.zeros title=numpy.zeros><span class=n>np</span><span class=o>.</span><span class=n>zeros</span></a><span class=p>((</span><a class="sphx-glr-backref-module-builtins sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://docs.python.org/3.8/library/functions.html#int title=builtins.int><span class=n>n_cond_img</span></a><span class=p>,</span> <a class="sphx-glr-backref-module-builtins sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://docs.python.org/3.8/library/functions.html#int title=builtins.int><span class=n>n_conds</span></a><span class=p>))</span>
<span class=c1># Gathering data for each condition and then use transformer from masker</span>
<span class=c1># object transform() on each data. The transformer extracts data in condition</span>
<span class=c1># maps where the target regions are specified by labels images</span>
<span class=k>for</span> <a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-attribute"href=https://numpy.org/doc/stable/reference/arrays.scalars.html#numpy.int64 title=numpy.int64><span class=n>i</span></a><span class=p>,</span> <a class="sphx-glr-backref-module-builtins sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://docs.python.org/3.8/library/stdtypes.html#str title=builtins.str><span class=n>cond</span></a> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray title=numpy.ndarray><span class=n>condition_names</span></a><span class=p>):</span>
    <a class="sphx-glr-backref-module-nibabel-nifti1 sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://nipy.org/nibabel/reference/nibabel.nifti1.html#nibabel.nifti1.Nifti1Image title=nibabel.nifti1.Nifti1Image><span class=n>cond_maps</span></a> <span class=o>=</span> <a class="sphx-glr-backref-module-nilearn-image sphx-glr-backref-type-py-function"href=../../modules/generated/nilearn.image.new_img_like.html#nilearn.image.new_img_like title=nilearn.image.new_img_like><span class=n>new_img_like</span></a><span class=p>(</span>
        <a class="sphx-glr-backref-module-nibabel-nifti1 sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://nipy.org/nibabel/reference/nibabel.nifti1.html#nibabel.nifti1.Nifti1Image title=nibabel.nifti1.Nifti1Image><span class=n>fmri_img</span></a><span class=p>,</span> <a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray title=numpy.ndarray><span class=n>fmri_data</span></a><span class=p>[</span><span class=o>...</span><span class=p>,</span> <a class="sphx-glr-backref-module-pandas-core-series sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.html#pandas.Series title=pandas.core.series.Series><span class=n>haxby_labels</span></a> <span class=o>==</span> <a class="sphx-glr-backref-module-builtins sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://docs.python.org/3.8/library/stdtypes.html#str title=builtins.str><span class=n>cond</span></a><span class=p>][</span><span class=o>...</span><span class=p>,</span> <span class=p>:</span><a class="sphx-glr-backref-module-builtins sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://docs.python.org/3.8/library/functions.html#int title=builtins.int><span class=n>n_cond_img</span></a><span class=p>])</span>
    <a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray title=numpy.ndarray><span class=n>mask_data</span></a> <span class=o>=</span> <a class="sphx-glr-backref-module-nilearn-maskers sphx-glr-backref-type-py-method"href=../../modules/generated/nilearn.maskers.NiftiLabelsMasker.html#nilearn.maskers.NiftiLabelsMasker.transform title=nilearn.maskers.NiftiLabelsMasker.transform><span class=n>masker</span><span class=o>.</span><span class=n>transform</span></a><span class=p>(</span><a class="sphx-glr-backref-module-nibabel-nifti1 sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://nipy.org/nibabel/reference/nibabel.nifti1.html#nibabel.nifti1.Nifti1Image title=nibabel.nifti1.Nifti1Image><span class=n>cond_maps</span></a><span class=p>)</span>
    <a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray title=numpy.ndarray><span class=n>X1</span></a><span class=p>[:,</span> <a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-attribute"href=https://numpy.org/doc/stable/reference/arrays.scalars.html#numpy.int64 title=numpy.int64><span class=n>i</span></a><span class=p>],</span> <a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray title=numpy.ndarray><span class=n>X2</span></a><span class=p>[:,</span> <a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-attribute"href=https://numpy.org/doc/stable/reference/arrays.scalars.html#numpy.int64 title=numpy.int64><span class=n>i</span></a><span class=p>]</span> <span class=o>=</span> <a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray title=numpy.ndarray><span class=n>mask_data</span></a><span class=p>[:,</span> <span class=mi>0</span><span class=p>],</span> <a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray title=numpy.ndarray><span class=n>mask_data</span></a><span class=p>[:,</span> <span class=mi>1</span><span class=p>]</span>
<a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray title=numpy.ndarray><span class=n>condition_names</span></a><span class=p>[</span><a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-function"href=https://numpy.org/doc/stable/reference/generated/numpy.where.html#numpy.where title=numpy.where><span class=n>np</span><span class=o>.</span><span class=n>where</span></a><span class=p>(</span><a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray title=numpy.ndarray><span class=n>condition_names</span></a> <span class=o>==</span> <span class=s1>'scrambledpix'</span><span class=p>)]</span> <span class=o>=</span> <span class=s1>'scrambled'</span>
</pre></div></div><p>save the ROI ‘atlas’ to a Nifti file</p><div class="highlight-default notranslate"><div class=highlight><pre><span></span><a class="sphx-glr-backref-module-nilearn-image sphx-glr-backref-type-py-function"href=../../modules/generated/nilearn.image.new_img_like.html#nilearn.image.new_img_like title=nilearn.image.new_img_like><span class=n>new_img_like</span></a><span class=p>(</span><a class="sphx-glr-backref-module-nibabel-nifti1 sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://nipy.org/nibabel/reference/nibabel.nifti1.html#nibabel.nifti1.Nifti1Image title=nibabel.nifti1.Nifti1Image><span class=n>fmri_img</span></a><span class=p>,</span> <a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray title=numpy.ndarray><span class=n>labels</span></a><span class=p>)</span><span class=o>.</span><span class=n>to_filename</span><span class=p>(</span><span class=s1>'mask_atlas.nii.gz'</span><span class=p>)</span>
</pre></div></div><p>Plot the average in the different condition names</p><div class="highlight-default notranslate"><div class=highlight><pre><span></span><span class=kn>import</span> <span class=nn>matplotlib.pyplot</span> <span class=k>as</span> <span class=nn>plt</span>

<a class="sphx-glr-backref-module-matplotlib-pyplot sphx-glr-backref-type-py-function"href=https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.figure.html#matplotlib.pyplot.figure title=matplotlib.pyplot.figure><span class=n>plt</span><span class=o>.</span><span class=n>figure</span></a><span class=p>(</span><span class=n>figsize</span><span class=o>=</span><span class=p>(</span><span class=mi>15</span><span class=p>,</span> <span class=mi>7</span><span class=p>))</span>
<span class=k>for</span> <a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-attribute"href=https://numpy.org/doc/stable/reference/arrays.scalars.html#numpy.int64 title=numpy.int64><span class=n>i</span></a> <span class=ow>in</span> <a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-function"href=https://numpy.org/doc/stable/reference/generated/numpy.arange.html#numpy.arange title=numpy.arange><span class=n>np</span><span class=o>.</span><span class=n>arange</span></a><span class=p>(</span><span class=mi>2</span><span class=p>):</span>
    <a class="sphx-glr-backref-module-matplotlib-pyplot sphx-glr-backref-type-py-function"href=https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.subplot.html#matplotlib.pyplot.subplot title=matplotlib.pyplot.subplot><span class=n>plt</span><span class=o>.</span><span class=n>subplot</span></a><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-attribute"href=https://numpy.org/doc/stable/reference/arrays.scalars.html#numpy.int64 title=numpy.int64><span class=n>i</span></a> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
    <a class="sphx-glr-backref-module-matplotlib-pyplot sphx-glr-backref-type-py-function"href=https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.boxplot.html#matplotlib.pyplot.boxplot title=matplotlib.pyplot.boxplot><span class=n>plt</span><span class=o>.</span><span class=n>boxplot</span></a><span class=p>(</span><a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray title=numpy.ndarray><span class=n>X1</span></a> <span class=k>if</span> <a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-attribute"href=https://numpy.org/doc/stable/reference/arrays.scalars.html#numpy.int64 title=numpy.int64><span class=n>i</span></a> <span class=o>==</span> <span class=mi>0</span> <span class=k>else</span> <a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray title=numpy.ndarray><span class=n>X2</span></a><span class=p>)</span>
    <a class="sphx-glr-backref-module-matplotlib-pyplot sphx-glr-backref-type-py-function"href=https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.xticks.html#matplotlib.pyplot.xticks title=matplotlib.pyplot.xticks><span class=n>plt</span><span class=o>.</span><span class=n>xticks</span></a><span class=p>(</span><a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-function"href=https://numpy.org/doc/stable/reference/generated/numpy.arange.html#numpy.arange title=numpy.arange><span class=n>np</span><span class=o>.</span><span class=n>arange</span></a><span class=p>(</span><span class=nb>len</span><span class=p>(</span><a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray title=numpy.ndarray><span class=n>condition_names</span></a><span class=p>))</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-class sphx-glr-backref-instance"href=https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray title=numpy.ndarray><span class=n>condition_names</span></a><span class=p>,</span>
               <span class=n>rotation</span><span class=o>=</span><span class=mi>25</span><span class=p>)</span>
    <a class="sphx-glr-backref-module-matplotlib-pyplot sphx-glr-backref-type-py-function"href=https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.title.html#matplotlib.pyplot.title title=matplotlib.pyplot.title><span class=n>plt</span><span class=o>.</span><span class=n>title</span></a><span class=p>(</span><span class=s1>'Boxplots of data in ROI</span><span class=si>%i</span><span class=s1> per condition'</span> <span class=o>%</span> <span class=p>(</span><a class="sphx-glr-backref-module-numpy sphx-glr-backref-type-py-attribute"href=https://numpy.org/doc/stable/reference/arrays.scalars.html#numpy.int64 title=numpy.int64><span class=n>i</span></a> <span class=o>+</span> <span class=mi>1</span><span class=p>))</span>

<a class="sphx-glr-backref-module-nilearn-plotting sphx-glr-backref-type-py-function"href=../../modules/generated/nilearn.plotting.show.html#nilearn.plotting.show title=nilearn.plotting.show><span class=n>show</span></a><span class=p>()</span>
</pre></div></div><img alt="Boxplots of data in ROI1 per condition, Boxplots of data in ROI2 per condition"class=sphx-glr-single-img src=../../_images/sphx_glr_plot_roi_extraction_008.png srcset=../../_images/sphx_glr_plot_roi_extraction_008.png><p class=sphx-glr-timing><strong>Total running time of the script:</strong> ( 0 minutes 40.576 seconds)</p><p><strong>Estimated memory usage:</strong> 2277 MB</p><div class="sphx-glr-footer class sphx-glr-footer-example docutils container"id=sphx-glr-download-auto-examples-06-manipulating-images-plot-roi-extraction-py><div class="binder-badge docutils container"><a class="reference external image-reference"href=https://mybinder.org/v2/gh/nilearn/nilearn.github.io/main?filepath=examples/auto_examples/06_manipulating_images/plot_roi_extraction.ipynb><img alt="Launch binder"src=../../_images/binder_badge_logo5.svg width=150px></a></div><div class="sphx-glr-download sphx-glr-download-python docutils container"><p><a class="reference download internal"download href=../../_downloads/d3c28de322e855141e45deb3d38a4a9c/plot_roi_extraction.py><code class="xref download docutils literal notranslate"><span class=pre>Download</span> <span class=pre>Python</span> <span class=pre>source</span> <span class=pre>code:</span> <span class=pre>plot_roi_extraction.py</span></code></a></p></div><div class="sphx-glr-download sphx-glr-download-jupyter docutils container"><p><a class="reference download internal"download href=../../_downloads/24c1df177618dd7609dc0967f9c2ce5b/plot_roi_extraction.ipynb><code class="xref download docutils literal notranslate"><span class=pre>Download</span> <span class=pre>Jupyter</span> <span class=pre>notebook:</span> <span class=pre>plot_roi_extraction.ipynb</span></code></a></p></div></div><p class=sphx-glr-signature><a class="reference external"href=https://sphinx-gallery.github.io>Gallery generated by Sphinx-Gallery</a></p></div></div><div class=clearer></div></div></div></div><div aria-label="main navigation"class=sphinxsidebar role=navigation><div class=sphinxsidebarwrapper><h4>Giving credit</h4><ul class=simple><li><p>Please consider <a href=../../authors.html#citing>citing the papers</a>.</p></li></ul><h3><a href=../../index.html>Table of Contents</a></h3><ul><li><a class="reference internal"href=#>9.7.12. Computing a Region of Interest (ROI) mask manually</a><ul><li><a class="reference internal"href=#loading-the-data>9.7.12.1. Loading the data</a></li><li><a class="reference internal"href=#build-a-statistical-test-to-find-voxels-of-interest>9.7.12.2. Build a statistical test to find voxels of interest</a></li><li><a class="reference internal"href=#build-a-mask-from-this-statistical-map-improving-the-quality-of-the-mask>9.7.12.3. Build a mask from this statistical map (Improving the quality of the mask)</a></li></ul></li></ul><h4>Previous topic</h4><p class=topless><a title="previous chapter"href=plot_affine_transformation.html><span class=section-number>9.7.11. </span>Visualization of affine resamplings</a></p><h4>Next topic</h4><p class=topless><a title="next chapter"href=../07_advanced/plot_ica_resting_state.html><span class=section-number>9.8.1. </span>Multivariate decompositions: Independent component analysis of fMRI</a></p><div id=searchbox role=search style=display:none><h3 id=searchlabel>Quick search</h3><div class=searchformwrapper><form action=../../search.html class=search><input aria-labelledby=searchlabel name=q><input type=submit value=Go></form></div></div><script>$('#searchbox').show(0);</script></div></div><div class=clearer></div></div><div class=footer>© The nilearn developers 2010-2022. Created using <a href=http://sphinx.pocoo.org/>Sphinx</a> 4.0.2. <span style=padding-left:5ex> <a href=../../_sources/auto_examples/06_manipulating_images/plot_roi_extraction.rst.txt rel=nofollow>Show this page source</a> </span></div></body></html>