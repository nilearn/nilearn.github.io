<!doctypehtml><html lang=en><meta charset=utf-8><meta content=width=device-width,initial-scale=1.0 name=viewport><meta content="2.5. Searchlight : finding voxels containing information"property=og:title><meta content=website property=og:type><meta content=https://nilearn.github.io/decoding/searchlight.html property=og:url><meta content=Nilearn property=og:site_name><meta content="This page overviews searchlight analyses and how they are approached in nilearn with the SearchLight estimator. Contents: Principle of the Searchlight, Preparing the data, Setting up the searchligh..."property=og:description><meta content=../_images/sphx_glr_plot_haxby_searchlight_001.png property=og:image><meta content=Nilearn property=og:image:alt><title>Nilearn: Statistical Analysis for NeuroImaging in Python — Machine learning for NeuroImaging</title><link href=../_static/pygments.css rel=stylesheet><link href=../_static/nature.css rel=stylesheet><link href=../_static/copybutton.css rel=stylesheet><link href=../_static/sg_gallery.css rel=stylesheet><link href=../_static/sg_gallery-binder.css rel=stylesheet><link href=../_static/sg_gallery-dataframe.css rel=stylesheet><link href=../_static/sg_gallery-rendered-html.css rel=stylesheet><script data-url_root=../ id=documentation_options src=../_static/documentation_options.js></script><script src=../_static/jquery.js></script><script src=../_static/underscore.js></script><script src=../_static/doctools.js></script><script src=../_static/clipboard.min.js></script><script src=../_static/copybutton.js></script><link rel="shortcut icon"href=../_static/favicon.ico><link href=../search.html rel=search title=Search><link title="2.6. Running scikit-learn functions for more control on the analysis"href=going_further.html rel=next><link title="2.4. SpaceNet: decoding with spatial structure for better maps"href=space_net.html rel=prev><meta content=True name=HandheldFriendly><meta content=width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0 name=viewport><meta content="nilearn, neuroimaging, python, neuroscience, machinelearning"name=keywords><script>function updateTopMenuPosition(height, width) {
    if($(window).scrollTop() > height && $(window).outerWidth() > 1024) {
        //begin to scroll
        $('.related-wrapper').css("z-index", 1000);
        $('.related-wrapper').css("position", "sticky");
        $('.related-wrapper').css("top", 0);
        $('.related-wrapper').css("width", width)
    } else {
        //lock it back into place
        $('.related-wrapper').css("position", "relative");
        $('.related-wrapper').css("top", 0)
    }
}

$(function() {
    var banner_height = $('#logo-banner').outerHeight();
    var banner_width = $('#logo-banner').outerWidth();
    var width = $('.related-wrapper').css("height", $('.related').outerHeight());

    updateTopMenuPosition(banner_height, width);

    $(window).scroll(function(event) {
        updateTopMenuPosition(banner_height, width)
    });

    $(window).resize(function(event) {
        var banner_width = $('#logo-banner').outerWidth();
        var menu_height = $('.related').outerHeight();
        $('.related').css("width", banner_width);
        $('.related-wrapper').css("height", menu_height);
        updateTopMenuPosition(banner_height, width)
    })
});</script><script>function updateSideBarPosition(top, offset, sections) {
    var pos = $(window).scrollTop();
    // Lock the table of content to a fixed position once we scroll enough
    var topShift = 2 * offset;
    if(pos > top + topShift + 1) {
        // begin to scroll with sticky menu bar
        var topShift = -topShift + 1;
        if ($(window).outerWidth() < 1024) {
            // compensate top menu that disappears
            topShift -= offset + 1
        }
        $('.sphinxsidebarwrapper').css("position", "fixed");
        $('.sphinxsidebarwrapper').css("top", topShift)
    }
    else {
        //lock it back into place
        $('.sphinxsidebarwrapper').css("position", "relative");
        $('.sphinxsidebarwrapper').css("top",0)
    }

    // Highlight the current section
    i = 0;
    current_section = 0;
    $('a.internal').removeClass('active');
    for(i in sections) {
        if(sections[i] > pos) {
            break
        }
        if($('a.internal[href$="' + i + '"]').is(':visible')){
            current_section = i
        }
    }
    $('a.internal[href$="' + current_section + '"]').addClass('active');
    $('a.internal[href$="' + current_section + '"]').parent().addClass('active')
}

$(function () {
    // Lock the table of content to a fixed position once we scroll enough
    var tocOffset = $('.related-wrapper').outerHeight();
    var marginTop = parseFloat($('.sphinxsidebarwrapper').css('margin-top').replace(/auto/, 0));
    var top = $('.sphinxsidebarwrapper').offset().top - marginTop;
    sections = {};
    url = document.URL.replace(/#.*$/, "");

    // Grab positions of our sections
    $('.headerlink').each(function(){
        sections[this.href.replace(url, '')] = $(this).offset().top - 50
    });

    updateSideBarPosition(top, tocOffset, sections);

    $(window).scroll(function(event) {
        updateSideBarPosition(top, tocOffset, sections)
    });

    $(window).resize(function(event) {
        tocOffset = $('.related-wrapper').outerHeight();
        updateSideBarPosition(top, tocOffset, sections)
    });
});</script><script>var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-41920728-1']);
        _gaq.push(['_trackPageview']);

        (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();</script><body><div id=logo-banner><div class=logo><a href=../index.html> <img alt="Nilearn logo"border=0 src=../_static/nilearn-logo.png> </a></div><div class=tags><ul><li><big><a href=../auto_examples/decoding/plot_haxby_anova_svm.html>SVM</a></big></li><li><small><a href=../connectivity/parcellating.html>Ward clustering</a></small></li><li><a href=#>Searchlight</a></li><li><big><a href=../connectivity/resting_state_networks.html>ICA</a></big></li><li><a href=../manipulating_images/data_preparation.html>Nifti IO</a></li><li><a href=../modules/reference.html#module-nilearn.datasets>Datasets</a></li></ul></div><div class=banner><h1>Nilearn:</h1><h2>Statistics for NeuroImaging in Python</h2></div><div class=search_form><div class=gcse-search id=cse style=width:100%></div><script>(function() {
        var cx = '017289614950330089114:elrt9qoutrq';
        var gcse = document.createElement('script');
        gcse.type = 'text/javascript';
        gcse.async = true;
        gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
        var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(gcse, s);
      })();</script></div></div><div class=related-wrapper><div aria-label="related navigation"class=related role=navigation><h3>Navigation</h3><ul><li class=right style=margin-right:10px><a title="Python Module Index"href=../py-modindex.html>modules</a></li><li class=right><a title="2.6. Running scikit-learn functions for more control on the analysis"accesskey=N href=going_further.html>next</a> |</li><li class=right><a title="2.4. SpaceNet: decoding with spatial structure for better maps"accesskey=P href=space_net.html>previous</a> |</li><li><a href=../index.html>Nilearn Home</a> | </li><li><a href=../user_guide.html>User Guide</a> | </li><li><a href=../auto_examples/index.html>Examples</a> | </li><li><a href=../modules/reference.html>Reference</a> | </li><li id=navbar-about><a href=../authors.html>About</a>| </li><li><a href=../glossary.html>Glossary</a>| </li><li><a href=../bibliography.html>Bibliography</a>| </li><li id=navbar-ecosystem><a href=http://www.nipy.org/>Nipy ecosystem</a></li><li class="nav-item nav-item-1"><a href=../user_guide.html>User guide: table of contents</a> »</li><li class="nav-item nav-item-2"><a accesskey=U href=index.html><span class=section-number>2. </span>Decoding and MVPA: predicting from brain images</a> »</li><li class="nav-item nav-item-this"><a href>Nilearn: Statistical Analysis for NeuroImaging in Python</a></li></ul></div></div><div class=stable-banner>This is the <em>stable</em> documentation for the latest release of Nilearn, the current development version is available <a href=https://nilearn.github.io/dev/index.html>here</a>.</div><div class=document><div class=documentwrapper><div class=bodywrapper><div class=body role=main><div class=section id=searchlight-finding-voxels-containing-information><span id=searchlight></span><h1><span class=section-number>2.5. </span>Searchlight : finding voxels containing information<a title="Permalink to this headline"class=headerlink href=#searchlight-finding-voxels-containing-information>¶</a></h1><p>This page overviews searchlight analyses and how they are approached in nilearn with the <a class="reference internal"href=../modules/generated/nilearn.decoding.SearchLight.html#nilearn.decoding.SearchLight title=nilearn.decoding.SearchLight><code class="xref py py-class docutils literal notranslate"><span class=pre>SearchLight</span></code></a> estimator.</p><div class="contents local topic"id=contents><p class=topic-title><strong>Contents</strong></p><ul class=simple><li><p><a class="reference internal"href=#principle-of-the-searchlight id=id11>Principle of the Searchlight</a></p></li><li><p><a class="reference internal"href=#preparing-the-data id=id12>Preparing the data</a></p></li><li><p><a class="reference internal"href=#setting-up-the-searchlight id=id13>Setting up the searchlight</a></p></li><li><p><a class="reference internal"href=#visualization id=id14>Visualization</a></p></li><li><p><a class="reference internal"href=#references id=id15>References</a></p></li></ul></div><div class=section id=principle-of-the-searchlight><h2><a class=toc-backref href=#id11><span class=section-number>2.5.1. </span>Principle of the Searchlight</a><a title="Permalink to this headline"class=headerlink href=#principle-of-the-searchlight>¶</a></h2><p><a class="reference internal"href=../modules/generated/nilearn.decoding.SearchLight.html#nilearn.decoding.SearchLight title=nilearn.decoding.SearchLight><code class="xref py py-class docutils literal notranslate"><span class=pre>SearchLight</span></code></a> analysis was introduced in [Kriegeskorte <em>et al.</em> <a class="footnote-reference brackets"href=#kriegeskorte3863 id=id1>3</a>], and consists of scanning the brain with a <em>searchlight</em>. Briefly, a ball of given radius is scanned across the brain volume and the prediction accuracy of a classifier trained on the corresponding <a class="reference internal"href=../glossary.html#term-voxel><span class="xref std std-term">voxels</span></a> is measured.</p><p>Searchlights are also not limited to <a class="reference internal"href=../glossary.html#term-classification><span class="xref std std-term">classification</span></a>; <a class="reference internal"href=../glossary.html#term-regression><span class="xref std std-term">regression</span></a> (e.g., [Kahnt <em>et al.</em> <a class="footnote-reference brackets"href=#kahnt2011549 id=id2>4</a>]) and representational similarity analysis (e.g., [Clarke and Tyler <a class="footnote-reference brackets"href=#clarke4766 id=id3>5</a>]) are other uses of searchlights. Currently, only <a class="reference internal"href=../glossary.html#term-classification><span class="xref std std-term">classification</span></a> and <a class="reference internal"href=../glossary.html#term-regression><span class="xref std std-term">regression</span></a> are supported in nilearn.</p><div class=topic><p class=topic-title><strong>Further Reading</strong></p><p>For a critical review on searchlights, see [Etzel <em>et al.</em> <a class="footnote-reference brackets"href=#etzel2013261 id=id4>6</a>].</p></div></div><div class=section id=preparing-the-data><h2><a class=toc-backref href=#id12><span class=section-number>2.5.2. </span>Preparing the data</a><a title="Permalink to this headline"class=headerlink href=#preparing-the-data>¶</a></h2><p><a class="reference internal"href=../modules/generated/nilearn.decoding.SearchLight.html#nilearn.decoding.SearchLight title=nilearn.decoding.SearchLight><code class="xref py py-class docutils literal notranslate"><span class=pre>SearchLight</span></code></a> requires a series of brain volumes as input, <cite>X</cite>, each with a corresponding label, <cite>y</cite>. The number of brain volumes therefore correspond to the number of samples used for decoding.</p><div class=section id=masking><h3><span class=section-number>2.5.2.1. </span>Masking<a title="Permalink to this headline"class=headerlink href=#masking>¶</a></h3><p>One of the main elements that distinguish <a class="reference internal"href=../modules/generated/nilearn.decoding.SearchLight.html#nilearn.decoding.SearchLight title=nilearn.decoding.SearchLight><code class="xref py py-class docutils literal notranslate"><span class=pre>SearchLight</span></code></a> from other algorithms is the notion of structuring element that scans the entire volume. This has an impact on the masking procedure.</p><p>Two masks are used with <a class="reference internal"href=../modules/generated/nilearn.decoding.SearchLight.html#nilearn.decoding.SearchLight title=nilearn.decoding.SearchLight><code class="xref py py-class docutils literal notranslate"><span class=pre>SearchLight</span></code></a>:</p><ul class=simple><li><p><em>mask_img</em> is the anatomical mask</p></li><li><p><em>process_mask_img</em> is a subset of the brain mask and defines the boundaries of where the searchlight scans the volume. Often times we are interested in only performing a searchlight within a specific area of the brain (e.g., frontal cortex). If no <em>process_mask_img</em> is set, then <a class="reference internal"href=../modules/generated/nilearn.decoding.SearchLight.html#nilearn.decoding.SearchLight title=nilearn.decoding.SearchLight><code class="xref py py-class docutils literal notranslate"><span class=pre>nilearn.decoding.SearchLight</span></code></a> defaults to performing a searchlight over the whole brain.</p></li></ul><p><em>mask_img</em> ensures that only <a class="reference internal"href=../glossary.html#term-voxel><span class="xref std std-term">voxels</span></a> with usable signals are included in the searchlight. This could be a full-brain mask or a gray-matter mask.</p></div></div><div class=section id=setting-up-the-searchlight><h2><a class=toc-backref href=#id13><span class=section-number>2.5.3. </span>Setting up the searchlight</a><a title="Permalink to this headline"class=headerlink href=#setting-up-the-searchlight>¶</a></h2><div class=section id=classifier><h3><span class=section-number>2.5.3.1. </span>Classifier<a title="Permalink to this headline"class=headerlink href=#classifier>¶</a></h3><p>The classifier used by default by <a class="reference internal"href=../modules/generated/nilearn.decoding.SearchLight.html#nilearn.decoding.SearchLight title=nilearn.decoding.SearchLight><code class="xref py py-class docutils literal notranslate"><span class=pre>SearchLight</span></code></a> is LinearSVC with C=1 but this can be customized easily by passing an estimator parameter to the Searchlight. See scikit-learn documentation for <a class="reference external"href=http://scikit-learn.org/stable/supervised_learning.html>other classifiers</a>. You can also pass scikit-learn <a class="reference external"href=https://scikit-learn.org/stable/modules/compose.html>Pipelines</a> to the <a class="reference internal"href=../modules/generated/nilearn.decoding.SearchLight.html#nilearn.decoding.SearchLight title=nilearn.decoding.SearchLight><code class="xref py py-class docutils literal notranslate"><span class=pre>SearchLight</span></code></a> in order to combine estimators and preprocessing steps (e.g., feature scaling) for your searchlight.</p></div><div class=section id=score-function><h3><span class=section-number>2.5.3.2. </span>Score function<a title="Permalink to this headline"class=headerlink href=#score-function>¶</a></h3><p>Metrics can be specified by the “scoring” argument to the <a class="reference internal"href=../modules/generated/nilearn.decoding.SearchLight.html#nilearn.decoding.SearchLight title=nilearn.decoding.SearchLight><code class="xref py py-class docutils literal notranslate"><span class=pre>SearchLight</span></code></a>, as detailed in the <a class="reference external"href=http://scikit-learn.org/dev/modules/model_evaluation.html#the-scoring-parameter-defining-model-evaluation-rules>scikit-learn documentation</a></p></div><div class=section id=cross-validation><h3><span class=section-number>2.5.3.3. </span>Cross validation<a title="Permalink to this headline"class=headerlink href=#cross-validation>¶</a></h3><p><a class="reference internal"href=../modules/generated/nilearn.decoding.SearchLight.html#nilearn.decoding.SearchLight title=nilearn.decoding.SearchLight><code class="xref py py-class docutils literal notranslate"><span class=pre>SearchLight</span></code></a> will iterate on the volume and give a score to each <a class="reference internal"href=../glossary.html#term-voxel><span class="xref std std-term">voxel</span></a>. This score is computed by running a classifier on selected <a class="reference internal"href=../glossary.html#term-voxel><span class="xref std std-term">voxels</span></a>. In order to make this score as accurate as possible (and avoid overfitting), cross-validation is used.</p><p>Cross-validation can be defined using the “cv” argument. As it is computationally costly, <em>K</em>-Fold cross validation with <em>K</em> = 3 is set as the default. A <a class="reference external"href=https://scikit-learn.org/stable/modules/classes.html#splitter-classes>scikit-learn cross-validation generator</a> can also be passed to set a specific type of cross-validation.</p><p>Leave-one-run-out cross-validation (LOROCV) is a common approach for searchlights. This approach is a specific use-case of grouped cross-validation, where the cross-validation folds are determined by the acquisition runs. The held-out fold in a given iteration of cross-validation consist of data from a separate run, which keeps training and validation sets properly independent. For this reason, LOROCV is often recommended. This can be performed by using <a class="reference external"href=https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.LeaveOneGroupOut.html>LeaveOneGroupOut</a>, and then setting the group/run labels when fitting the estimator.</p></div><div class=section id=sphere-radius><h3><span class=section-number>2.5.3.4. </span>Sphere radius<a title="Permalink to this headline"class=headerlink href=#sphere-radius>¶</a></h3><p>An important parameter is the radius of the sphere that will run through the data. The sphere size determines the number of voxels/features to use for <a class="reference internal"href=../glossary.html#term-classification><span class="xref std std-term">classification</span></a> (i.e. more <a class="reference internal"href=../glossary.html#term-voxel><span class="xref std std-term">voxels</span></a> are included with larger spheres).</p><div class="admonition note"><p class=admonition-title>Note</p><p><a class="reference internal"href=../modules/generated/nilearn.decoding.SearchLight.html#nilearn.decoding.SearchLight title=nilearn.decoding.SearchLight><code class="xref py py-class docutils literal notranslate"><span class=pre>SearchLight</span></code></a> defines sphere radius in millimeters; the number of <a class="reference internal"href=../glossary.html#term-voxel><span class="xref std std-term">voxels</span></a> included in the sphere will therefore depend on the <a class="reference internal"href=../glossary.html#term-voxel><span class="xref std std-term">voxel</span></a> size.</p><p>For reference, [Kriegeskorte <em>et al.</em> <a class="footnote-reference brackets"href=#kriegeskorte3863 id=id5>3</a>] use a 4mm radius because it yielded the best detection performance in their simulation of 2mm isovoxel data.</p></div></div></div><div class=section id=visualization><h2><a class=toc-backref href=#id14><span class=section-number>2.5.4. </span>Visualization</a><a title="Permalink to this headline"class=headerlink href=#visualization>¶</a></h2><div class=section id=id6><h3><span class=section-number>2.5.4.1. </span>Searchlight<a title="Permalink to this headline"class=headerlink href=#id6>¶</a></h3><p>The results of the searchlight can be found in the <cite>scores_</cite> attribute of the <a class="reference internal"href=../modules/generated/nilearn.decoding.SearchLight.html#nilearn.decoding.SearchLight title=nilearn.decoding.SearchLight><code class="xref py py-class docutils literal notranslate"><span class=pre>SearchLight</span></code></a> object after fitting it to the data. Below is a visualization of the results from <a class="reference internal"href=../auto_examples/02_decoding/plot_haxby_searchlight.html#sphx-glr-auto-examples-02-decoding-plot-haxby-searchlight-py><span class="std std-ref">Searchlight analysis of face vs house recognition</span></a>. The searchlight was restricted to a slice in the back of the brain. Within this slice, we can see that a cluster of <a class="reference internal"href=../glossary.html#term-voxel><span class="xref std std-term">voxels</span></a> in visual cortex contains information to distinguish pictures showed to the volunteers, which was the expected result.</p><div class="figure align-center"><a class="reference external image-reference"href=../auto_examples/02_decoding/plot_haxby_searchlight.html><img alt=../_images/sphx_glr_plot_haxby_searchlight_001.png src=../_images/sphx_glr_plot_haxby_searchlight_001.png style=width:176px;height:183.2px></a></div><div class="admonition seealso"><p class=admonition-title>See also</p><ul class=simple><li><p><a class="reference internal"href=../plotting/index.html#plotting><span class="std std-ref">Plotting brain images</span></a></p></li></ul></div></div><div class=section id=comparing-to-massively-univariate-analysis-f-score-or-spm><h3><span class=section-number>2.5.4.2. </span>Comparing to massively univariate analysis: F_score or SPM<a title="Permalink to this headline"class=headerlink href=#comparing-to-massively-univariate-analysis-f-score-or-spm>¶</a></h3><p>The standard approach to brain mapping is performed using <em>Statistical Parametric Mapping</em> (<a class="reference internal"href=../glossary.html#term-SPM><span class="xref std std-term">SPM</span></a>), using <a class="reference internal"href=../glossary.html#term-ANOVA><span class="xref std std-term">ANOVA</span></a> (analysis of variance), and parametric tests (F-tests ot t-tests). Here we compute the <em>p-values</em> of the <a class="reference internal"href=../glossary.html#term-voxel><span class="xref std std-term">voxels</span></a> <a class="footnote-reference brackets"href=#id9 id=id7>1</a>. To display the results, we use the negative log of the p-value.</p><div class="figure align-center"><a class="reference external image-reference"href=../auto_examples/02_decoding/plot_haxby_searchlight.html><img alt=../_images/sphx_glr_plot_haxby_searchlight_002.png src=../_images/sphx_glr_plot_haxby_searchlight_002.png style=width:176px;height:183.2px></a></div><p>Parametric scores can be converted into p-values using a reference theoretical distribution, which is known under specific assumptions (hence the name <em>parametric</em>). In practice, neuroimaging signal has a complex structure that might not match these assumptions. An exact, non-parametric <em>permutation test</em> can be performed as an alternative to the parametric test: the residuals of the model are permuted so as to break any effect and the corresponding decision statistic is recomputed. One thus builds the distribution of the decision statistic under the hypothesis that there is no relationship between the tested variates and the target variates. In neuroimaging, this is generally done by swapping the signal values of all <a class="reference internal"href=../glossary.html#term-voxel><span class="xref std std-term">voxels</span></a> while the tested variables remain unchanged <a class="footnote-reference brackets"href=#id10 id=id8>2</a>. A voxel-wise analysis is then performed on the permuted data. The relationships between the image descriptors and the tested variates are broken while the value of the signal in each particular <a class="reference internal"href=../glossary.html#term-voxel><span class="xref std std-term">voxel</span></a> can be observed with the same probability than the original value associated to that <a class="reference internal"href=../glossary.html#term-voxel><span class="xref std std-term">voxel</span></a>. Note that it is hereby assumed that the signal distribution is the same in every <a class="reference internal"href=../glossary.html#term-voxel><span class="xref std std-term">voxel</span></a>. Several data permutations are performed (typically 10,000) while the scores for every <a class="reference internal"href=../glossary.html#term-voxel><span class="xref std std-term">voxel</span></a> and every data permutation is stored. The empirical distribution of the scores is thus constructed (under the hypothesis that there is no relationship between the tested variates and the neuroimaging signal, the so-called <em>null-hypothesis</em>) and we can compare the original scores to that distribution: The higher the rank of the original score, the smaller is its associated p-value. The <a class="reference internal"href=../modules/generated/nilearn.mass_univariate.permuted_ols.html#nilearn.mass_univariate.permuted_ols title=nilearn.mass_univariate.permuted_ols><code class="xref py py-func docutils literal notranslate"><span class=pre>nilearn.mass_univariate.permuted_ols</span></code></a> function returns the p-values computed with a permutation test.</p><p>The number of tests performed is generally large when full-brain analysis is performed (> 50,000 voxels). This increases the probability of finding a significant activation by chance, a phenomenon that is known to statisticians as the <em>multiple comparisons problem</em>. It is therefore recommended to correct the p-values to take into account the multiple tests. <em>Bonferroni correction</em> consists of multiplying the p-values by the number of tests (while making sure the p-values remain smaller than 1). Thus, we control the occurrence of one false detection <em>at most</em>, the so-called <em>family-wise error control</em>. A similar control can be performed when performing a permutation test: For each permutation, only the maximum value of the F-statistic across <a class="reference internal"href=../glossary.html#term-voxel><span class="xref std std-term">voxels</span></a> is considered and is used to build the null distribution. It is crucial to assume that the distribution of the signal is the same in every <a class="reference internal"href=../glossary.html#term-voxel><span class="xref std std-term">voxel</span></a> so that the F-statistics are comparable. This correction strategy is applied in nilearn <a class="reference internal"href=../modules/generated/nilearn.mass_univariate.permuted_ols.html#nilearn.mass_univariate.permuted_ols title=nilearn.mass_univariate.permuted_ols><code class="xref py py-func docutils literal notranslate"><span class=pre>nilearn.mass_univariate.permuted_ols</span></code></a> function.</p><div class="figure align-center"><a class="reference external image-reference"href=../auto_examples/07_advanced/plot_haxby_mass_univariate.html><img alt=../_images/sphx_glr_plot_haxby_mass_univariate_001.png src=../_images/sphx_glr_plot_haxby_mass_univariate_001.png style=width:174px;height:137.4px></a></div><p>We observe that the results obtained with a permutation test are less conservative than the ones obtained with a Bonferroni correction strategy.</p><p>In nilearn <a class="reference internal"href=../modules/generated/nilearn.mass_univariate.permuted_ols.html#nilearn.mass_univariate.permuted_ols title=nilearn.mass_univariate.permuted_ols><code class="xref py py-func docutils literal notranslate"><span class=pre>nilearn.mass_univariate.permuted_ols</span></code></a> function, we permute a parametric t-test. Unlike F-test, a t-test can be signed (<em>one-sided test</em>), that is both the absolute value and the sign of an effect are considered. Thus, only positive effects can be focused on. It is still possible to perform a two-sided test equivalent to a permuted F-test by setting the argument <cite>two_sided_test</cite> to <cite>True</cite>. In the example above, we do perform a two-sided test but add back the sign of the effect at the end using the t-scores obtained on the original (non-permuted) data. Thus, we can perform two one-sided tests (a given contrast and its opposite) for the price of one single run. The example results can be interpreted as follows: viewing faces significantly activates the Fusiform Face Area as compared to viewing houses, while viewing houses does not reveal significant supplementary activations as compared to viewing faces.</p><dl class="footnote brackets"><dt class=label id=id9><span class=brackets><a class=fn-backref href=#id7>1</a></span></dt><dd><p>The <em>p-value</em> is the probability of getting the observed values assuming that nothing happens (i.e. under the null hypothesis). Therefore, a small <em>p-value</em> indicates that there is a small chance of getting this data if no real difference existed, so the observed voxel must be significant.</p></dd><dt class=label id=id10><span class=brackets><a class=fn-backref href=#id8>2</a></span></dt><dd><p>When the variate tested is a scalar (test of the <em>intercept</em>) –which corresponds to a one sample test–, no swapping can be performed but one can estimate the null distribution by assuming symmetry about some reference value. When this value is zero, one can randomly swap the sign of the target variates (the imaging signal). nilearn <a class="reference internal"href=../modules/generated/nilearn.mass_univariate.permuted_ols.html#nilearn.mass_univariate.permuted_ols title=nilearn.mass_univariate.permuted_ols><code class="xref py py-func docutils literal notranslate"><span class=pre>nilearn.mass_univariate.permuted_ols</span></code></a> function automatically adopts the suitable strategy according to the input data.</p></dd></dl><div class=topic><p class=topic-title><strong>Example code</strong></p><p>All the steps discussed in this section can be seen implemented in <a class="reference internal"href=../auto_examples/02_decoding/plot_haxby_searchlight.html#sphx-glr-auto-examples-02-decoding-plot-haxby-searchlight-py><span class="std std-ref">a full code example</span></a>.</p></div></div></div><div class=section id=references><h2><a class=toc-backref href=#id15><span class=section-number>2.5.5. </span>References</a><a title="Permalink to this headline"class=headerlink href=#references>¶</a></h2><p><dl class="footnote brackets"><dt class=label id=kriegeskorte3863><span class=brackets>3</span><span class=fn-backref>(<a href=#id1>1</a>,<a href=#id5>2</a>)</span></dt><dd><p>Nikolaus Kriegeskorte, Rainer Goebel, and Peter Bandettini. Information-based functional brain mapping. <em>Proceedings of the National Academy of Sciences</em>, 103(10):3863–3868, 2006. URL: <a class="reference external"href=https://www.pnas.org/content/103/10/3863>https://www.pnas.org/content/103/10/3863</a>, <a class="reference external"href=https://doi.org/10.1073/pnas.0600244103>doi:10.1073/pnas.0600244103</a>.</p></dd><dt class=label id=kahnt2011549><span class=brackets><a class=fn-backref href=#id2>4</a></span></dt><dd><p>Thorsten Kahnt, Marcus Grueschow, Oliver Speck, and John-Dylan Haynes. Perceptual learning and decision-making in human medial frontal cortex. <em>Neuron</em>, 70(3):549–559, 2011. URL: <a class="reference external"href=https://www.sciencedirect.com/science/article/pii/S0896627311002960>https://www.sciencedirect.com/science/article/pii/S0896627311002960</a>, <a class="reference external"href=https://doi.org/https://doi.org/10.1016/j.neuron.2011.02.054>doi:https://doi.org/10.1016/j.neuron.2011.02.054</a>.</p></dd><dt class=label id=clarke4766><span class=brackets><a class=fn-backref href=#id3>5</a></span></dt><dd><p>Alex Clarke and Lorraine K. Tyler. Object-specific semantic coding in human perirhinal cortex. <em>Journal of Neuroscience</em>, 34(14):4766–4775, 2014. URL: <a class="reference external"href=https://www.jneurosci.org/content/34/14/4766>https://www.jneurosci.org/content/34/14/4766</a>, <a class="reference external"href=https://arxiv.org/abs/https://www.jneurosci.org/content/34/14/4766.full.pdf>arXiv:https://www.jneurosci.org/content/34/14/4766.full.pdf</a>, <a class="reference external"href=https://doi.org/10.1523/JNEUROSCI.2828-13.2014>doi:10.1523/JNEUROSCI.2828-13.2014</a>.</p></dd><dt class=label id=etzel2013261><span class=brackets><a class=fn-backref href=#id4>6</a></span></dt><dd><p>Joset A. Etzel, Jeffrey M. Zacks, and Todd S. Braver. Searchlight analysis: promise, pitfalls, and potential. <em>NeuroImage</em>, 78:261–269, 2013. URL: <a class="reference external"href=https://www.sciencedirect.com/science/article/pii/S1053811913002917>https://www.sciencedirect.com/science/article/pii/S1053811913002917</a>, <a class="reference external"href=https://doi.org/https://doi.org/10.1016/j.neuroimage.2013.03.041>doi:https://doi.org/10.1016/j.neuroimage.2013.03.041</a>.</p></dd></dl></div></div><div class=clearer></div></div></div></div><div aria-label="main navigation"class=sphinxsidebar role=navigation><div class=sphinxsidebarwrapper><h4>Giving credit</h4><ul class=simple><li><p>Please consider <a href=../authors.html#citing>citing the papers</a>.</p></li></ul><h3><a href=../index.html>Table of Contents</a></h3><ul><li><a class="reference internal"href=#>2.5. Searchlight : finding voxels containing information</a><ul><li><a class="reference internal"href=#principle-of-the-searchlight>2.5.1. Principle of the Searchlight</a></li><li><a class="reference internal"href=#preparing-the-data>2.5.2. Preparing the data</a><ul><li><a class="reference internal"href=#masking>2.5.2.1. Masking</a></li></ul></li><li><a class="reference internal"href=#setting-up-the-searchlight>2.5.3. Setting up the searchlight</a><ul><li><a class="reference internal"href=#classifier>2.5.3.1. Classifier</a></li><li><a class="reference internal"href=#score-function>2.5.3.2. Score function</a></li><li><a class="reference internal"href=#cross-validation>2.5.3.3. Cross validation</a></li><li><a class="reference internal"href=#sphere-radius>2.5.3.4. Sphere radius</a></li></ul></li><li><a class="reference internal"href=#visualization>2.5.4. Visualization</a><ul><li><a class="reference internal"href=#id6>2.5.4.1. Searchlight</a></li><li><a class="reference internal"href=#comparing-to-massively-univariate-analysis-f-score-or-spm>2.5.4.2. Comparing to massively univariate analysis: F_score or SPM</a></li></ul></li><li><a class="reference internal"href=#references>2.5.5. References</a></li></ul></li></ul><h4>Previous topic</h4><p class=topless><a title="previous chapter"href=space_net.html><span class=section-number>2.4. </span>SpaceNet: decoding with spatial structure for better maps</a></p><h4>Next topic</h4><p class=topless><a title="next chapter"href=going_further.html><span class=section-number>2.6. </span>Running scikit-learn functions for more control on the analysis</a></p><div id=searchbox role=search style=display:none><h3 id=searchlabel>Quick search</h3><div class=searchformwrapper><form action=../search.html class=search><input aria-labelledby=searchlabel name=q><input type=submit value=Go></form></div></div><script>$('#searchbox').show(0);</script></div></div><div class=clearer></div></div><div class=footer>© The nilearn developers 2010-2022. Created using <a href=http://sphinx.pocoo.org/>Sphinx</a> 4.0.2. <span style=padding-left:5ex> <a href=../_sources/decoding/searchlight.rst.txt rel=nofollow>Show this page source</a> </span></div></body></html>