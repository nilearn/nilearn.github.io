<!doctypehtml><html lang=en xmlns=http://www.w3.org/1999/xhtml><meta content=IE=Edge http-equiv=X-UA-Compatible><meta content="text/html; charset=utf-8"http-equiv=Content-Type><title>Nilearn: Statistical Analysis for NeuroImaging in Python — Machine learning for NeuroImaging</title><link href=../_static/nature.css rel=stylesheet><link href=../_static/pygments.css rel=stylesheet><link href=../_static/gallery.css rel=stylesheet><link href=../_static/gallery-binder.css rel=stylesheet><link href=../_static/gallery-dataframe.css rel=stylesheet><script data-url_root=../ id=documentation_options src=../_static/documentation_options.js></script><script src=../_static/jquery.js></script><script src=../_static/underscore.js></script><script src=../_static/doctools.js></script><script src=../_static/language_data.js></script><script src=../_static/copybutton.js></script><link rel="shortcut icon"href=../_static/favicon.ico><link href=../search.html rel=search title=Search><link title="2.6. Running scikit-learn functions for more control on the analysis"href=going_further.html rel=next><link title="2.4. SpaceNet: decoding with spatial structure for better maps"href=space_net.html rel=prev><meta content=True name=HandheldFriendly><meta content=width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0 name=viewport><meta content="nilearn, neuroimaging, python, neuroscience, machinelearning"name=keywords><script>function updateTopMenuPosition(height, width) {
    if($(window).scrollTop() > height && $(window).outerWidth() > 1024) {
        //begin to scroll
        $('.related-wrapper').css("z-index", 1000);
        $('.related-wrapper').css("position", "sticky");
        $('.related-wrapper').css("top", 0);
        $('.related-wrapper').css("width", width)
    } else {
        //lock it back into place
        $('.related-wrapper').css("position", "relative");
        $('.related-wrapper').css("top", 0)
    }
}

$(function() {
    var banner_height = $('#logo-banner').outerHeight();
    var banner_width = $('#logo-banner').outerWidth();
    var width = $('.related-wrapper').css("height", $('.related').outerHeight());

    updateTopMenuPosition(banner_height, width);

    $(window).scroll(function(event) {
        updateTopMenuPosition(banner_height, width)
    });

    $(window).resize(function(event) {
        var banner_width = $('#logo-banner').outerWidth();
        var menu_height = $('.related').outerHeight();
        $('.related').css("width", banner_width);
        $('.related-wrapper').css("height", menu_height);
        updateTopMenuPosition(banner_height, width)
    })
});</script><script>function updateSideBarPosition(top, offset, sections) {
    var pos = $(window).scrollTop();
    // Lock the table of content to a fixed position once we scroll enough
    var topShift = 2 * offset;
    if(pos > top + topShift + 1) {
        // begin to scroll with sticky menu bar
        var topShift = -topShift + 1;
        if ($(window).outerWidth() < 1024) {
            // compensate top menu that disappears
            topShift -= offset + 1
        }
        $('.sphinxsidebarwrapper').css("position", "fixed");
        $('.sphinxsidebarwrapper').css("top", topShift)
    }
    else {
        //lock it back into place
        $('.sphinxsidebarwrapper').css("position", "relative");
        $('.sphinxsidebarwrapper').css("top",0)
    }

    // Highlight the current section
    i = 0;
    current_section = 0;
    $('a.internal').removeClass('active');
    for(i in sections) {
        if(sections[i] > pos) {
            break
        }
        if($('a.internal[href$="' + i + '"]').is(':visible')){
            current_section = i
        }
    }
    $('a.internal[href$="' + current_section + '"]').addClass('active');
    $('a.internal[href$="' + current_section + '"]').parent().addClass('active')
}

$(function () {
    // Lock the table of content to a fixed position once we scroll enough
    var tocOffset = $('.related-wrapper').outerHeight();
    var marginTop = parseFloat($('.sphinxsidebarwrapper').css('margin-top').replace(/auto/, 0));
    var top = $('.sphinxsidebarwrapper').offset().top - marginTop;
    sections = {};
    url = document.URL.replace(/#.*$/, "");

    // Grab positions of our sections
    $('.headerlink').each(function(){
        sections[this.href.replace(url, '')] = $(this).offset().top - 50
    });

    updateSideBarPosition(top, tocOffset, sections);

    $(window).scroll(function(event) {
        updateSideBarPosition(top, tocOffset, sections)
    });

    $(window).resize(function(event) {
        tocOffset = $('.related-wrapper').outerHeight();
        updateSideBarPosition(top, tocOffset, sections)
    });
});</script><script>var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-41920728-1']);
        _gaq.push(['_trackPageview']);

        (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();</script></head><body><div id=logo-banner><div class=logo><a href=../index.html> <img alt="Nilearn logo"border=0 src=../_static/nilearn-logo.png> </a></div><div class=tags><ul><li><big><a href=../auto_examples/decoding/plot_haxby_anova_svm.html>SVM</a></big></li><li><small><a href=../connectivity/parcellating.html>Ward clustering</a></small></li><li><a href=#>Searchlight</a></li><li><big><a href=../connectivity/resting_state_networks.html>ICA</a></big></li><li><a href=../manipulating_images/data_preparation.html>Nifti IO</a></li><li><a href=../modules/reference.html#module-nilearn.datasets>Datasets</a></li></ul></div><div class=banner><h1>Nilearn:</h1><h2>Statistics for NeuroImaging in Python</h2></div><div class=search_form><div class=gcse-search id=cse style=width:100%></div><script>(function() {
        var cx = '017289614950330089114:elrt9qoutrq';
        var gcse = document.createElement('script');
        gcse.type = 'text/javascript';
        gcse.async = true;
        gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
        var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(gcse, s);
      })();</script></div></div><div class=related-wrapper><div aria-label="related navigation"class=related role=navigation><h3>Navigation</h3><ul><li class=right style=margin-right:10px><a title="Python Module Index"href=../py-modindex.html>modules</a></li><li class=right><a title="2.6. Running scikit-learn functions for more control on the analysis"accesskey=N href=going_further.html>next</a> |</li><li class=right><a title="2.4. SpaceNet: decoding with spatial structure for better maps"accesskey=P href=space_net.html>previous</a> |</li><li><a href=../index.html>Nilearn Home</a> | </li><li><a href=../user_guide.html>User Guide</a> | </li><li><a href=../auto_examples/index.html>Examples</a> | </li><li><a href=../modules/reference.html>Reference</a> | </li><li id=navbar-about><a href=../authors.html>About</a>| </li><li id=navbar-ecosystem><a href=http://www.nipy.org/>Nipy ecosystem</a></li><li class="nav-item nav-item-1"><a href=../user_guide.html>User guide: table of contents</a> »</li><li class="nav-item nav-item-2"><a accesskey=U href=index.html>2. Decoding and MVPA: predicting from brain images</a> »</li></ul></div></div><div class=document><div class=documentwrapper><div class=bodywrapper><div class=body role=main><div class=section id=searchlight-finding-voxels-containing-information><span id=searchlight></span><h1>2.5. Searchlight : finding voxels containing information<a title="Permalink to this headline"class=headerlink href=#searchlight-finding-voxels-containing-information>¶</a></h1><p>This page overviews searchlight analyses and how they are approached in nilearn with the <a class="reference internal"href=../modules/generated/nilearn.decoding.SearchLight.html#nilearn.decoding.SearchLight title=nilearn.decoding.SearchLight><code class="xref py py-class docutils literal notranslate"><span class=pre>SearchLight</span></code></a> estimator.</p><div class="contents local topic"id=contents><p class=topic-title><strong>Contents</strong></p><ul class=simple><li><a class="reference internal"href=#principle-of-the-searchlight id=id6>Principle of the Searchlight</a></li><li><a class="reference internal"href=#preparing-the-data id=id7>Preparing the data</a></li><li><a class="reference internal"href=#setting-up-the-searchlight id=id8>Setting up the searchlight</a></li><li><a class="reference internal"href=#visualization id=id9>Visualization</a></li></ul></div><div class=section id=principle-of-the-searchlight><h2><a class=toc-backref href=#id6>2.5.1. Principle of the Searchlight</a><a title="Permalink to this headline"class=headerlink href=#principle-of-the-searchlight>¶</a></h2><p>Searchlight analysis was introduced in <a class="reference external"href=http://www.pnas.org/content/103/10/3863>Information-based functional brain mapping</a> (Kriegeskorte et al., 2006), and consists of scanning the brain with a <em>searchlight</em>. Briefly, a ball of given radius is scanned across the brain volume and the prediction accuracy of a classifier trained on the corresponding voxels is measured.</p><p>Searchlights are also not limited to classification; regression (e.g., <a class="reference external"href=https://www.sciencedirect.com/science/article/pii/S0896627311002960?via%3Dihub>Kahnt et al, 2011</a>) and representational similarity analysis (e.g., <a class="reference external"href=https://www.jneurosci.org/content/34/14/4766.short>Clarke and Tyler, 2014</a>) are other uses of searchlights. Currently, only classification and regression are supported in nilearn.</p><div class=topic><p class=topic-title><strong>Further Reading</strong></p><p>For a critical review on searchlights, see <a class="reference external"href=https://www.sciencedirect.com/science/article/pii/S1053811913002917>Etzel et al (2013)</a>.</p></div></div><div class=section id=preparing-the-data><h2><a class=toc-backref href=#id7>2.5.2. Preparing the data</a><a title="Permalink to this headline"class=headerlink href=#preparing-the-data>¶</a></h2><p><a class="reference internal"href=../modules/generated/nilearn.decoding.SearchLight.html#nilearn.decoding.SearchLight title=nilearn.decoding.SearchLight><code class="xref py py-class docutils literal notranslate"><span class=pre>SearchLight</span></code></a> requires a series of brain volumes as input, <cite>X</cite>, each with a corresponding label, <cite>y</cite>. The number of brain volumes therefore correspond to the number of samples used for decoding.</p><div class=section id=masking><h3>2.5.2.1. Masking<a title="Permalink to this headline"class=headerlink href=#masking>¶</a></h3><p>One of the main elements that distinguish <a class="reference internal"href=../modules/generated/nilearn.decoding.SearchLight.html#nilearn.decoding.SearchLight title=nilearn.decoding.SearchLight><code class="xref py py-class docutils literal notranslate"><span class=pre>SearchLight</span></code></a> from other algorithms is the notion of structuring element that scans the entire volume. This has an impact on the masking procedure.</p><p>Two masks are used with <a class="reference internal"href=../modules/generated/nilearn.decoding.SearchLight.html#nilearn.decoding.SearchLight title=nilearn.decoding.SearchLight><code class="xref py py-class docutils literal notranslate"><span class=pre>SearchLight</span></code></a>:</p><ul class=simple><li><em>mask_img</em> is the anatomical mask</li><li><em>process_mask_img</em> is a subset of the brain mask and defines the boundaries of where the searchlight scans the volume. Often times we are interested in only performing a searchlight within a specific area of the brain (e.g., frontal cortex). If no <em>process_mask_img</em> is set, then <a class="reference internal"href=../modules/generated/nilearn.decoding.SearchLight.html#nilearn.decoding.SearchLight title=nilearn.decoding.SearchLight><code class="xref py py-class docutils literal notranslate"><span class=pre>SearchLight</span></code></a> defaults to performing a searchlight over the whole brain.</li></ul><p><em>mask_img</em> ensures that only voxels with useable signals are included in the searchlight. This could be a full-brain mask or a gray-matter mask.</p></div></div><div class=section id=setting-up-the-searchlight><h2><a class=toc-backref href=#id8>2.5.3. Setting up the searchlight</a><a title="Permalink to this headline"class=headerlink href=#setting-up-the-searchlight>¶</a></h2><div class=section id=classifier><h3>2.5.3.1. Classifier<a title="Permalink to this headline"class=headerlink href=#classifier>¶</a></h3><p>The classifier used by default by <a class="reference internal"href=../modules/generated/nilearn.decoding.SearchLight.html#nilearn.decoding.SearchLight title=nilearn.decoding.SearchLight><code class="xref py py-class docutils literal notranslate"><span class=pre>SearchLight</span></code></a> is LinearSVC with C=1 but this can be customized easily by passing an estimator parameter to the Searchlight. See scikit-learn documentation for <a class="reference external"href=http://scikit-learn.org/stable/supervised_learning.html>other classifiers</a>. You can also pass scikit-learn <a class="reference external"href=https://scikit-learn.org/stable/modules/compose.html>Pipelines</a> to the <a class="reference internal"href=../modules/generated/nilearn.decoding.SearchLight.html#nilearn.decoding.SearchLight title=nilearn.decoding.SearchLight><code class="xref py py-class docutils literal notranslate"><span class=pre>SearchLight</span></code></a> in order to combine estimators and preprocessing steps (e.g., feature scaling) for your searchlight.</p></div><div class=section id=score-function><h3>2.5.3.2. Score function<a title="Permalink to this headline"class=headerlink href=#score-function>¶</a></h3><p>Metrics can be specified by the “scoring” argument to the <a class="reference internal"href=../modules/generated/nilearn.decoding.SearchLight.html#nilearn.decoding.SearchLight title=nilearn.decoding.SearchLight><code class="xref py py-class docutils literal notranslate"><span class=pre>SearchLight</span></code></a>, as detailed in the <a class="reference external"href=http://scikit-learn.org/dev/modules/model_evaluation.html#the-scoring-parameter-defining-model-evaluation-rules>scikit-learn documentation</a></p></div><div class=section id=cross-validation><h3>2.5.3.3. Cross validation<a title="Permalink to this headline"class=headerlink href=#cross-validation>¶</a></h3><p><a class="reference internal"href=../modules/generated/nilearn.decoding.SearchLight.html#nilearn.decoding.SearchLight title=nilearn.decoding.SearchLight><code class="xref py py-class docutils literal notranslate"><span class=pre>SearchLight</span></code></a> will iterate on the volume and give a score to each voxel. This score is computed by running a classifier on selected voxels. In order to make this score as accurate as possible (and avoid overfitting), cross-validation is used.</p><p>Cross-validation can be defined using the “cv” argument. As it is computationally costly, <em>K</em>-Fold cross validation with <em>K</em> = 3 is set as the default. A <a class="reference external"href=https://scikit-learn.org/stable/modules/classes.html#splitter-classes>scikit-learn cross-validation generator</a> can also be passed to set a specific type of cross-validation.</p><p>Leave-one-run-out cross-validation (LOROCV) is a common approach for searchlights. This approach is a specific use-case of grouped cross-validation, where the cross-validation folds are determined by the acquisition runs. The held-out fold in a given iteration of cross-validation consist of data from a separate run, which keeps training and validation sets properly independent. For this reason, LOROCV is often recommended. This can be performed by using <a class="reference external"href=https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.LeaveOneGroupOut.html>LeaveOneGroupOut</a>, and then setting the group/run labels when fitting the estimator.</p></div><div class=section id=sphere-radius><h3>2.5.3.4. Sphere radius<a title="Permalink to this headline"class=headerlink href=#sphere-radius>¶</a></h3><p>An important parameter is the radius of the sphere that will run through the data. The sphere size determines the number of voxels/features to use for classification (i.e. more voxels are included with larger spheres).</p><div class="admonition note"><p class="first admonition-title">Note</p><p><a class="reference internal"href=../modules/generated/nilearn.decoding.SearchLight.html#nilearn.decoding.SearchLight title=nilearn.decoding.SearchLight><code class="xref py py-class docutils literal notranslate"><span class=pre>SearchLight</span></code></a> defines sphere radius in milimeters; the number of voxels included in the sphere will therefore depend on the voxel size.</p><p class=last>For reference, Kriegskorte et al. use a 4mm radius because it yielded the best detection performance in their simulation of 2mm isovoxel data.</p></div></div></div><div class=section id=visualization><h2><a class=toc-backref href=#id9>2.5.4. Visualization</a><a title="Permalink to this headline"class=headerlink href=#visualization>¶</a></h2><div class=section id=id1><h3>2.5.4.1. Searchlight<a title="Permalink to this headline"class=headerlink href=#id1>¶</a></h3><p>The results of the searchlight can be found in the <cite>scores_</cite> attribute of the <a class="reference internal"href=../modules/generated/nilearn.decoding.SearchLight.html#nilearn.decoding.SearchLight title=nilearn.decoding.SearchLight><code class="xref py py-class docutils literal notranslate"><span class=pre>SearchLight</span></code></a> object after fitting it to the data. Below is a visualization of the results from <a class="reference internal"href=../auto_examples/02_decoding/plot_haxby_searchlight.html#sphx-glr-auto-examples-02-decoding-plot-haxby-searchlight-py><span class="std std-ref">Searchlight analysis of face vs house recognition</span></a>. The searchlight was restriced to a slice in the back of the brain. Within this slice, we can see that a cluster of voxels in visual cortex contains information to distinguish pictures showed to the volunteers, which was the expected result.</p><div class="figure align-center"><a class="reference external image-reference"href=../auto_examples/02_decoding/plot_haxby_searchlight.html><img alt=../_images/sphx_glr_plot_haxby_searchlight_0011.png src=../_images/sphx_glr_plot_haxby_searchlight_0011.png style=width:176px;height:183.2px></a></div><div class="admonition seealso"><p class="first admonition-title">See also</p><ul class="last simple"><li><a class="reference internal"href=../plotting/index.html#plotting><span class="std std-ref">Plotting brain images</span></a></li></ul></div></div><div class=section id=comparing-to-massively-univariate-analysis-f-score-or-spm><h3>2.5.4.2. Comparing to massively univariate analysis: F_score or SPM<a title="Permalink to this headline"class=headerlink href=#comparing-to-massively-univariate-analysis-f-score-or-spm>¶</a></h3><p>The standard approach to brain mapping is performed using <em>Statistical Parametric Mapping</em> (SPM), using ANOVA (analysis of variance), and parametric tests (F-tests ot t-tests). Here we compute the <em>p-values</em> of the voxels <a class=footnote-reference href=#id4 id=id2>[1]</a>. To display the results, we use the negative log of the p-value.</p><div class="figure align-center"><a class="reference external image-reference"href=../auto_examples/02_decoding/plot_haxby_searchlight.html><img alt=../_images/sphx_glr_plot_haxby_searchlight_0021.png src=../_images/sphx_glr_plot_haxby_searchlight_0021.png style=width:176px;height:183.2px></a></div><p>Parametric scores can be converted into p-values using a reference theoretical distribution, which is known under specific assumptions (hence the name <em>parametric</em>). In practice, neuroimaging signal has a complex structure that might not match these assumptions. An exact, non-parametric <em>permutation test</em> can be performed as an alternative to the parametric test: the residuals of the model are permuted so as to break any effect and the corresponding decision statistic is recomputed. One thus builds the distribution of the decision statistic under the hypothesis that there is no relationship between the tested variates and the target variates. In neuroimaging, this is generally done by swapping the signal values of all voxels while the tested variables remain unchanged <a class=footnote-reference href=#id5 id=id3>[2]</a>. A voxel-wise analysis is then performed on the permuted data. The relationships between the image descriptors and the tested variates are broken while the value of the signal in each particular voxel can be observed with the same probability than the original value associated to that voxel. Note that it is hereby assumed that the signal distribution is the same in every voxel. Several data permutations are performed (typically 10,000) while the scores for every voxel and every data permutation is stored. The empirical distribution of the scores is thus constructed (under the hypothesis that there is no relationship between the tested variates and the neuroimaging signal, the so-called <em>null-hypothesis</em>) and we can compare the original scores to that distribution: The higher the rank of the original score, the smaller is its associated p-value. The <a class="reference internal"href=../modules/generated/nilearn.mass_univariate.permuted_ols.html#nilearn.mass_univariate.permuted_ols title=nilearn.mass_univariate.permuted_ols><code class="xref py py-func docutils literal notranslate"><span class=pre>nilearn.mass_univariate.permuted_ols</span></code></a> function returns the p-values computed with a permutation test.</p><p>The number of tests performed is generally large when full-brain analysis is performed (> 50,000 voxels). This increases the probability of finding a significant activation by chance, a phenomenon that is known to statisticians as the <em>multiple comparisons problem</em>. It is therefore recommended to correct the p-values to take into account the multiple tests. <em>Bonferroni correction</em> consists of multiplying the p-values by the number of tests (while making sure the p-values remain smaller than 1). Thus, we control the occurrence of one false detection <em>at most</em>, the so-called <em>family-wise error control</em>. A similar control can be performed when performing a permutation test: For each permutation, only the maximum value of the F-statistic across voxels is considered and is used to build the null distribution. It is crucial to assume that the distribution of the signal is the same in every voxel so that the F-statistics are comparable. This correction strategy is applied in nilearn <a class="reference internal"href=../modules/generated/nilearn.mass_univariate.permuted_ols.html#nilearn.mass_univariate.permuted_ols title=nilearn.mass_univariate.permuted_ols><code class="xref py py-func docutils literal notranslate"><span class=pre>nilearn.mass_univariate.permuted_ols</span></code></a> function.</p><div class="figure align-center"><a class="reference external image-reference"href=../auto_examples/07_advanced/plot_haxby_mass_univariate.html><img alt=../_images/sphx_glr_plot_haxby_mass_univariate_0011.png src=../_images/sphx_glr_plot_haxby_mass_univariate_0011.png style=width:174px;height:137.4px></a></div><p>We observe that the results obtained with a permutation test are less conservative than the ones obtained with a Bonferroni correction strategy.</p><p>In nilearn <a class="reference internal"href=../modules/generated/nilearn.mass_univariate.permuted_ols.html#nilearn.mass_univariate.permuted_ols title=nilearn.mass_univariate.permuted_ols><code class="xref py py-func docutils literal notranslate"><span class=pre>nilearn.mass_univariate.permuted_ols</span></code></a> function, we permute a parametric t-test. Unlike F-test, a t-test can be signed (<em>one-sided test</em>), that is both the absolute value and the sign of an effect are considered. Thus, only positive effects can be focused on. It is still possible to perform a two-sided test equivalent to a permuted F-test by setting the argument <cite>two_sided_test</cite> to <cite>True</cite>. In the example above, we do perform a two-sided test but add back the sign of the effect at the end using the t-scores obtained on the original (non-permuted) data. Thus, we can perform two one-sided tests (a given contrast and its opposite) for the price of one single run. The example results can be interpreted as follows: viewing faces significantly activates the Fusiform Face Area as compared to viewing houses, while viewing houses does not reveal significant supplementary activations as compared to viewing faces.</p><table class="docutils footnote"frame=void id=id4 rules=none><colgroup><col class=label><col></colgroup><tbody valign=top><tr><td class=label><a class=fn-backref href=#id2>[1]</a></td><td>The <em>p-value</em> is the probability of getting the observed values assuming that nothing happens (i.e. under the null hypothesis). Therefore, a small <em>p-value</em> indicates that there is a small chance of getting this data if no real difference existed, so the observed voxel must be significant.</td></tr></tbody></table><table class="docutils footnote"frame=void id=id5 rules=none><colgroup><col class=label><col></colgroup><tbody valign=top><tr><td class=label><a class=fn-backref href=#id3>[2]</a></td><td>When the variate tested is a scalar (test of the <em>intercept</em>) –which corresponds to a one sample test–, no swapping can be performed but one can estimate the null distribution by assuming symmetry about some reference value. When this value is zero, one can randomly swap the sign of the target variates (the imaging signal). nilearn <a class="reference internal"href=../modules/generated/nilearn.mass_univariate.permuted_ols.html#nilearn.mass_univariate.permuted_ols title=nilearn.mass_univariate.permuted_ols><code class="xref py py-func docutils literal notranslate"><span class=pre>nilearn.mass_univariate.permuted_ols</span></code></a> function automatically adopts the suitable strategy according to the input data.</td></tr></tbody></table><div class=topic><p class=topic-title><strong>Example code</strong></p><p>All the steps discussed in this section can be seen implemented in <a class="reference internal"href=../auto_examples/02_decoding/plot_haxby_searchlight.html#sphx-glr-auto-examples-02-decoding-plot-haxby-searchlight-py><span class="std std-ref">a full code example</span></a>.</p></div></div></div></div></div></div></div><div aria-label="main navigation"class=sphinxsidebar role=navigation><div class=sphinxsidebarwrapper><h4>Giving credit</h4><ul class=simple><li><p>Please consider <a href=../authors.html#citing>citing the papers</a>.</p></li></ul><h3><a href=../index.html>Table of Contents</a></h3><ul><li><a class="reference internal"href=#>2.5. Searchlight : finding voxels containing information</a><ul><li><a class="reference internal"href=#principle-of-the-searchlight>2.5.1. Principle of the Searchlight</a></li><li><a class="reference internal"href=#preparing-the-data>2.5.2. Preparing the data</a><ul><li><a class="reference internal"href=#masking>2.5.2.1. Masking</a></li></ul></li><li><a class="reference internal"href=#setting-up-the-searchlight>2.5.3. Setting up the searchlight</a><ul><li><a class="reference internal"href=#classifier>2.5.3.1. Classifier</a></li><li><a class="reference internal"href=#score-function>2.5.3.2. Score function</a></li><li><a class="reference internal"href=#cross-validation>2.5.3.3. Cross validation</a></li><li><a class="reference internal"href=#sphere-radius>2.5.3.4. Sphere radius</a></li></ul></li><li><a class="reference internal"href=#visualization>2.5.4. Visualization</a><ul><li><a class="reference internal"href=#id1>2.5.4.1. Searchlight</a></li><li><a class="reference internal"href=#comparing-to-massively-univariate-analysis-f-score-or-spm>2.5.4.2. Comparing to massively univariate analysis: F_score or SPM</a></li></ul></li></ul></li></ul><h4>Previous topic</h4><p class=topless><a title="previous chapter"href=space_net.html>2.4. SpaceNet: decoding with spatial structure for better maps</a></p><h4>Next topic</h4><p class=topless><a title="next chapter"href=going_further.html>2.6. Running scikit-learn functions for more control on the analysis</a></p><div id=searchbox role=search style=display:none><h3>Quick search</h3><div class=searchformwrapper><form action=../search.html class=search><input name=q><input type=submit value=Go><input name=check_keywords type=hidden value=yes><input name=area type=hidden value=default></form></div></div><script>$('#searchbox').show(0);</script></div></div><div class=clearer></div></div><div class=footer>© The nilearn developers 2010-2020. Created using <a href=http://sphinx.pocoo.org/>Sphinx</a> 1.8.5. <span style=padding-left:5ex> <a href=../_sources/decoding/searchlight.rst.txt rel=nofollow>Show this page source</a> </span></div></body></html>