<!doctypehtml><html lang=en xmlns=http://www.w3.org/1999/xhtml><meta content=IE=Edge http-equiv=X-UA-Compatible><meta content="text/html; charset=utf-8"http-equiv=Content-Type><title>Nilearn: Statistical Analysis for NeuroImaging in Python — Machine learning for NeuroImaging</title><link href=../_static/nature.css rel=stylesheet><link href=../_static/pygments.css rel=stylesheet><link href=../_static/gallery.css rel=stylesheet><link href=../_static/gallery-binder.css rel=stylesheet><link href=../_static/gallery-dataframe.css rel=stylesheet><script data-url_root=../ id=documentation_options src=../_static/documentation_options.js></script><script src=../_static/jquery.js></script><script src=../_static/underscore.js></script><script src=../_static/doctools.js></script><script src=../_static/language_data.js></script><script src=../_static/copybutton.js></script><link rel="shortcut icon"href=../_static/favicon.ico><link href=../search.html rel=search title=Search><link title="3.2. Connectome extraction: inverse covariance for direct connections"href=connectome_extraction.html rel=next><link title="3. Functional connectivity and resting state"href=index.html rel=prev><meta content=True name=HandheldFriendly><meta content=width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0 name=viewport><meta content="nilearn, neuroimaging, python, neuroscience, machinelearning"name=keywords><script>function updateTopMenuPosition(height, width) {
    if($(window).scrollTop() > height && $(window).outerWidth() > 1024) {
        //begin to scroll
        $('.related-wrapper').css("z-index", 1000);
        $('.related-wrapper').css("position", "sticky");
        $('.related-wrapper').css("top", 0);
        $('.related-wrapper').css("width", width)
    } else {
        //lock it back into place
        $('.related-wrapper').css("position", "relative");
        $('.related-wrapper').css("top", 0)
    }
}

$(function() {
    var banner_height = $('#logo-banner').outerHeight();
    var banner_width = $('#logo-banner').outerWidth();
    var width = $('.related-wrapper').css("height", $('.related').outerHeight());

    updateTopMenuPosition(banner_height, width);

    $(window).scroll(function(event) {
        updateTopMenuPosition(banner_height, width)
    });

    $(window).resize(function(event) {
        var banner_width = $('#logo-banner').outerWidth();
        var menu_height = $('.related').outerHeight();
        $('.related').css("width", banner_width);
        $('.related-wrapper').css("height", menu_height);
        updateTopMenuPosition(banner_height, width)
    })
});</script><script>function updateSideBarPosition(top, offset, sections) {
    var pos = $(window).scrollTop();
    // Lock the table of content to a fixed position once we scroll enough
    var topShift = 2 * offset;
    if(pos > top + topShift + 1) {
        // begin to scroll with sticky menu bar
        var topShift = -topShift + 1;
        if ($(window).outerWidth() < 1024) {
            // compensate top menu that disappears
            topShift -= offset + 1
        }
        $('.sphinxsidebarwrapper').css("position", "fixed");
        $('.sphinxsidebarwrapper').css("top", topShift)
    }
    else {
        //lock it back into place
        $('.sphinxsidebarwrapper').css("position", "relative");
        $('.sphinxsidebarwrapper').css("top",0)
    }

    // Highlight the current section
    i = 0;
    current_section = 0;
    $('a.internal').removeClass('active');
    for(i in sections) {
        if(sections[i] > pos) {
            break
        }
        if($('a.internal[href$="' + i + '"]').is(':visible')){
            current_section = i
        }
    }
    $('a.internal[href$="' + current_section + '"]').addClass('active');
    $('a.internal[href$="' + current_section + '"]').parent().addClass('active')
}

$(function () {
    // Lock the table of content to a fixed position once we scroll enough
    var tocOffset = $('.related-wrapper').outerHeight();
    var marginTop = parseFloat($('.sphinxsidebarwrapper').css('margin-top').replace(/auto/, 0));
    var top = $('.sphinxsidebarwrapper').offset().top - marginTop;
    sections = {};
    url = document.URL.replace(/#.*$/, "");

    // Grab positions of our sections
    $('.headerlink').each(function(){
        sections[this.href.replace(url, '')] = $(this).offset().top - 50
    });

    updateSideBarPosition(top, tocOffset, sections);

    $(window).scroll(function(event) {
        updateSideBarPosition(top, tocOffset, sections)
    });

    $(window).resize(function(event) {
        tocOffset = $('.related-wrapper').outerHeight();
        updateSideBarPosition(top, tocOffset, sections)
    });
});</script><script>var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-41920728-1']);
        _gaq.push(['_trackPageview']);

        (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();</script></head><body><div id=logo-banner><div class=logo><a href=../index.html> <img alt="Nilearn logo"border=0 src=../_static/nilearn-logo.png> </a></div><div class=tags><ul><li><big><a href=../auto_examples/decoding/plot_haxby_anova_svm.html>SVM</a></big></li><li><small><a href=parcellating.html>Ward clustering</a></small></li><li><a href=../decoding/searchlight.html>Searchlight</a></li><li><big><a href=resting_state_networks.html>ICA</a></big></li><li><a href=../manipulating_images/data_preparation.html>Nifti IO</a></li><li><a href=../modules/reference.html#module-nilearn.datasets>Datasets</a></li></ul></div><div class=banner><h1>Nilearn:</h1><h2>Statistics for NeuroImaging in Python</h2></div><div class=search_form><div class=gcse-search id=cse style=width:100%></div><script>(function() {
        var cx = '017289614950330089114:elrt9qoutrq';
        var gcse = document.createElement('script');
        gcse.type = 'text/javascript';
        gcse.async = true;
        gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
        var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(gcse, s);
      })();</script></div></div><div class=related-wrapper><div aria-label="related navigation"class=related role=navigation><h3>Navigation</h3><ul><li class=right style=margin-right:10px><a title="Python Module Index"href=../py-modindex.html>modules</a></li><li class=right><a title="3.2. Connectome extraction: inverse covariance for direct connections"accesskey=N href=connectome_extraction.html>next</a> |</li><li class=right><a title="3. Functional connectivity and resting state"accesskey=P href=index.html>previous</a> |</li><li><a href=../index.html>Nilearn Home</a> | </li><li><a href=../user_guide.html>User Guide</a> | </li><li><a href=../auto_examples/index.html>Examples</a> | </li><li><a href=../modules/reference.html>Reference</a> | </li><li id=navbar-about><a href=../authors.html>About</a>| </li><li id=navbar-ecosystem><a href=http://www.nipy.org/>Nipy ecosystem</a></li><li class="nav-item nav-item-1"><a href=../user_guide.html>User guide: table of contents</a> »</li><li class="nav-item nav-item-2"><a accesskey=U href=index.html>3. Functional connectivity and resting state</a> »</li></ul></div></div><div class=document><div class=documentwrapper><div class=bodywrapper><div class=body role=main><div class=section id=extracting-times-series-to-build-a-functional-connectome><span id=functional-connectomes></span><h1>3.1. Extracting times series to build a functional connectome<a title="Permalink to this headline"class=headerlink href=#extracting-times-series-to-build-a-functional-connectome>¶</a></h1><div class=topic><p class=topic-title><strong>Page summary</strong></p><p>A <em>functional connectome</em> is a set of connections representing brain interactions between regions. Here we show how to extract activation time-series to compute functional connectomes.</p></div><div class="contents local topic"id=contents><p class=topic-title><strong>Contents</strong></p><ul class=simple><li><a class="reference internal"href=#time-series-from-a-brain-parcellation-or-maxprob-atlas id=id3>Time-series from a brain parcellation or “MaxProb” atlas</a></li><li><a class="reference internal"href=#time-series-from-a-probabilistic-atlas id=id4>Time-series from a probabilistic atlas</a></li><li><a class="reference internal"href=#a-functional-connectome-a-graph-of-interactions id=id5>A functional connectome: a graph of interactions</a></li><li><a class="reference internal"href=#a-functional-connectome-extracting-coordinates-of-regions id=id6>A functional connectome: extracting coordinates of regions</a></li></ul></div><div class=topic><p class=topic-title><strong>References</strong></p><ul class=simple><li><a class="reference external"href=http://www.sciencedirect.com/science/article/pii/S1053811913003340>Varoquaux and Craddock, “Learning and comparing functional connectomes across subjects”, NeuroImage 2013</a>.</li></ul></div><div class=section id=time-series-from-a-brain-parcellation-or-maxprob-atlas><span id=parcellation-time-series></span><h2><a class=toc-backref href=#id3>3.1.1. Time-series from a brain parcellation or “MaxProb” atlas</a><a title="Permalink to this headline"class=headerlink href=#time-series-from-a-brain-parcellation-or-maxprob-atlas>¶</a></h2><div class=section id=brain-parcellations><h3>3.1.1.1. Brain parcellations<a title="Permalink to this headline"class=headerlink href=#brain-parcellations>¶</a></h3><p>Regions used to extract the signal can be defined by a “hard” parcellation. For instance, the <a class="reference internal"href=../modules/reference.html#module-nilearn.datasets title=nilearn.datasets><code class="xref py py-mod docutils literal notranslate"><span class=pre>nilearn.datasets</span></code></a> has functions to download atlases forming reference parcellation, e.g., <a class="reference internal"href=../modules/generated/nilearn.datasets.fetch_atlas_craddock_2012.html#nilearn.datasets.fetch_atlas_craddock_2012 title=nilearn.datasets.fetch_atlas_craddock_2012><code class="xref py py-func docutils literal notranslate"><span class=pre>fetch_atlas_craddock_2012</span></code></a>, <a class="reference internal"href=../modules/generated/nilearn.datasets.fetch_atlas_harvard_oxford.html#nilearn.datasets.fetch_atlas_harvard_oxford title=nilearn.datasets.fetch_atlas_harvard_oxford><code class="xref py py-func docutils literal notranslate"><span class=pre>fetch_atlas_harvard_oxford</span></code></a>, <a class="reference internal"href=../modules/generated/nilearn.datasets.fetch_atlas_yeo_2011.html#nilearn.datasets.fetch_atlas_yeo_2011 title=nilearn.datasets.fetch_atlas_yeo_2011><code class="xref py py-func docutils literal notranslate"><span class=pre>fetch_atlas_yeo_2011</span></code></a>.</p><p>For instance to retrieve the Harvard-Oxford cortical parcellation, sampled at 2mm, and with a threshold of a probability of 0.25:</p><div class="highlight-default notranslate"><div class=highlight><pre><span></span><span class=kn>from</span> <span class=nn>nilearn</span> <span class=k>import</span> <span class=n>datasets</span>
<span class=n>dataset</span> <span class=o>=</span> <span class=n>datasets</span><span class=o>.</span><span class=n>fetch_atlas_harvard_oxford</span><span class=p>(</span><span class=s1>'cort-maxprob-thr25-2mm'</span><span class=p>)</span>
<span class=n>atlas_filename</span> <span class=o>=</span> <span class=n>dataset</span><span class=o>.</span><span class=n>maps</span>
<span class=n>labels</span> <span class=o>=</span> <span class=n>dataset</span><span class=o>.</span><span class=n>labels</span>
</pre></div></div><p>Plotting can then be done as:</p><div class="highlight-default notranslate"><div class=highlight><pre><span></span><span class=kn>from</span> <span class=nn>nilearn</span> <span class=k>import</span> <span class=n>plotting</span>
<span class=n>plotting</span><span class=o>.</span><span class=n>plot_roi</span><span class=p>(</span><span class=n>atlas_filename</span><span class=p>)</span>
</pre></div></div><a class="reference external image-reference"href=../auto_examples/01_plotting/plot_atlas.html><img alt=../_images/sphx_glr_plot_atlas_0011.png src=../_images/sphx_glr_plot_atlas_0011.png style=width:396px;height:156px></a><div class="admonition seealso"><p class="first admonition-title">See also</p><ul class="last simple"><li>The <a class="reference internal"href=../plotting/index.html#plotting><span class="std std-ref">plotting documentation</span></a>;</li><li>The <a class="reference internal"href=../modules/reference.html#datasets-ref><span class="std std-ref">dataset downloaders</span></a>.</li></ul></div></div><div class=section id=extracting-signals-on-a-parcellation><h3>3.1.1.2. Extracting signals on a parcellation<a title="Permalink to this headline"class=headerlink href=#extracting-signals-on-a-parcellation>¶</a></h3><p>To extract signal on the parcellation, the easiest option is to use the <a class="reference internal"href=../modules/generated/nilearn.input_data.NiftiLabelsMasker.html#nilearn.input_data.NiftiLabelsMasker title=nilearn.input_data.NiftiLabelsMasker><code class="xref py py-class docutils literal notranslate"><span class=pre>nilearn.input_data.NiftiLabelsMasker</span></code></a>. As any “maskers” in nilearn, it is a processing object that is created by specifying all the important parameters, but not the data:</p><div class="highlight-default notranslate"><div class=highlight><pre><span></span><span class=kn>from</span> <span class=nn>nilearn.input_data</span> <span class=k>import</span> <span class=n>NiftiLabelsMasker</span>
<span class=n>masker</span> <span class=o>=</span> <span class=n>NiftiLabelsMasker</span><span class=p>(</span><span class=n>labels_img</span><span class=o>=</span><span class=n>atlas_filename</span><span class=p>,</span> <span class=n>standardize</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</pre></div></div><p>The Nifti data can then be turned to time-series by calling the <a class="reference internal"href=../modules/generated/nilearn.input_data.NiftiLabelsMasker.html#nilearn.input_data.NiftiLabelsMasker title=nilearn.input_data.NiftiLabelsMasker><code class="xref py py-class docutils literal notranslate"><span class=pre>NiftiLabelsMasker</span></code></a> <cite>fit_transform</cite> method, that takes either filenames or <a class="reference external"href=http://nipy.org/nibabel/nibabel_images.html>NiftiImage objects</a>:</p><div class="highlight-default notranslate"><div class=highlight><pre><span></span><span class=n>time_series</span> <span class=o>=</span> <span class=n>masker</span><span class=o>.</span><span class=n>fit_transform</span><span class=p>(</span><span class=n>frmi_files</span><span class=p>,</span> <span class=n>confounds</span><span class=o>=</span><span class=n>csv_file</span><span class=p>)</span>
</pre></div></div><div class=line-block><div class=line><br></div></div><p>Note that confound signals can be specified in the call. Indeed, to obtain time series that capture well the functional interactions between regions, regressing out noise sources is indeed very important <a class="reference external"href=https://hal.inria.fr/hal-00812911/>[Varoquaux & Craddock 2013]</a>.</p><a class="reference external image-reference"href=../auto_examples/03_connectivity/plot_signal_extraction.html><img alt=../_images/sphx_glr_plot_signal_extraction_0011.png src=../_images/sphx_glr_plot_signal_extraction_0011.png style=width:400px;height:320px></a><a class="reference external image-reference"href=../auto_examples/03_connectivity/plot_signal_extraction.html><img alt=../_images/sphx_glr_plot_signal_extraction_0021.png src=../_images/sphx_glr_plot_signal_extraction_0021.png style=width:400px;height:320px></a><div class=topic><p class=topic-title><strong>Full example</strong></p><p>See the following example for a full file running the analysis: <a class="reference internal"href=../auto_examples/03_connectivity/plot_signal_extraction.html#sphx-glr-auto-examples-03-connectivity-plot-signal-extraction-py><span class="std std-ref">Extracting signals from a brain parcellation</span></a>.</p></div><div class="green topic"><p class=topic-title><strong>Exercise: computing the correlation matrix of rest fmri</strong></p><p>Try using the information above to compute the correlation matrix of the first subject of the brain development dataset downloaded with <a class="reference internal"href=../modules/generated/nilearn.datasets.fetch_development_fmri.html#nilearn.datasets.fetch_development_fmri title=nilearn.datasets.fetch_development_fmri><code class="xref py py-func docutils literal notranslate"><span class=pre>nilearn.datasets.fetch_development_fmri</span></code></a>.</p><p><strong>Hints:</strong></p><ul class=simple><li>Inspect the ‘.keys()’ of the object returned by <a class="reference internal"href=../modules/generated/nilearn.datasets.fetch_development_fmri.html#nilearn.datasets.fetch_development_fmri title=nilearn.datasets.fetch_development_fmri><code class="xref py py-func docutils literal notranslate"><span class=pre>nilearn.datasets.fetch_development_fmri</span></code></a>.</li><li><a class="reference internal"href=../modules/generated/nilearn.connectome.ConnectivityMeasure.html#nilearn.connectome.ConnectivityMeasure title=nilearn.connectome.ConnectivityMeasure><code class="xref py py-class docutils literal notranslate"><span class=pre>nilearn.connectome.ConnectivityMeasure</span></code></a> can be used to compute a correlation matrix (check the shape of your matrices).</li><li><a class="reference external"title="(in Matplotlib v3.3.3)"href=https://matplotlib.org/api/_as_gen/matplotlib.pyplot.imshow.html#matplotlib.pyplot.imshow><code class="xref py py-func docutils literal notranslate"><span class=pre>matplotlib.pyplot.imshow</span></code></a> can show a correlation matrix.</li><li>The example above has the solution.</li></ul></div><div class=line-block><div class=line><br></div></div></div></div><div class=section id=time-series-from-a-probabilistic-atlas><h2><a class=toc-backref href=#id4>3.1.2. Time-series from a probabilistic atlas</a><a title="Permalink to this headline"class=headerlink href=#time-series-from-a-probabilistic-atlas>¶</a></h2><div class=section id=probabilistic-atlases><h3>3.1.2.1. Probabilistic atlases<a title="Permalink to this headline"class=headerlink href=#probabilistic-atlases>¶</a></h3><p>The definition of regions as by a continuous probability map captures better our imperfect knowledge of boundaries in brain images (notably because of inter-subject registration errors). One example of such an atlas well suited to resting-state or naturalistic-stimuli data analysis is the <a class="reference external"href=https://team.inria.fr/parietal/18-2/spatial_patterns/spatial-patterns-in-resting-state/>MSDL atlas</a> (<a class="reference internal"href=../modules/generated/nilearn.datasets.fetch_atlas_msdl.html#nilearn.datasets.fetch_atlas_msdl title=nilearn.datasets.fetch_atlas_msdl><code class="xref py py-func docutils literal notranslate"><span class=pre>nilearn.datasets.fetch_atlas_msdl</span></code></a>).</p><p>Probabilistic atlases are represented as a set of continuous maps, in a 4D nifti image. Visualization the atlas thus requires to visualize each of these maps, which requires accessing them with <a class="reference internal"href=../modules/generated/nilearn.image.index_img.html#nilearn.image.index_img title=nilearn.image.index_img><code class="xref py py-func docutils literal notranslate"><span class=pre>nilearn.image.index_img</span></code></a> (see the <a class="reference internal"href=../auto_examples/01_plotting/plot_overlay.html#sphx-glr-auto-examples-01-plotting-plot-overlay-py><span class="std std-ref">corresponding example</span></a>).</p><a class="reference external image-reference"href=../auto_examples/01_plotting/plot_overlay.html><img alt=../_images/sphx_glr_plot_overlay_0011.png src=../_images/sphx_glr_plot_overlay_0011.png style=width:396px;height:156px></a></div><div class=section id=extracting-signals-from-a-probabilistic-atlas><h3>3.1.2.2. Extracting signals from a probabilistic atlas<a title="Permalink to this headline"class=headerlink href=#extracting-signals-from-a-probabilistic-atlas>¶</a></h3><p>As with extraction of signals on a parcellation, extracting signals from a probabilistic atlas can be done with a “masker” object: the <a class="reference internal"href=../modules/generated/nilearn.input_data.NiftiMapsMasker.html#nilearn.input_data.NiftiMapsMasker title=nilearn.input_data.NiftiMapsMasker><code class="xref py py-class docutils literal notranslate"><span class=pre>nilearn.input_data.NiftiMapsMasker</span></code></a>. It is created by specifying the important parameters, in particular the atlas:</p><div class="highlight-default notranslate"><div class=highlight><pre><span></span><span class=kn>from</span> <span class=nn>nilearn.input_data</span> <span class=k>import</span> <span class=n>NiftiMapsMasker</span>
<span class=n>masker</span> <span class=o>=</span> <span class=n>NiftiMapsMasker</span><span class=p>(</span><span class=n>maps_img</span><span class=o>=</span><span class=n>atlas_filename</span><span class=p>,</span> <span class=n>standardize</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</pre></div></div><p>The <cite>fit_transform</cite> method turns filenames or <a class="reference external"href=http://nipy.org/nibabel/nibabel_images.html>NiftiImage objects</a> to time series:</p><div class="highlight-default notranslate"><div class=highlight><pre><span></span><span class=n>time_series</span> <span class=o>=</span> <span class=n>masker</span><span class=o>.</span><span class=n>fit_transform</span><span class=p>(</span><span class=n>frmi_files</span><span class=p>,</span> <span class=n>confounds</span><span class=o>=</span><span class=n>csv_file</span><span class=p>)</span>
</pre></div></div><p>The procedure is the same as with <a class="reference external"href=parcellation_time_series>brain parcellations</a> but using the <a class="reference internal"href=../modules/generated/nilearn.input_data.NiftiMapsMasker.html#nilearn.input_data.NiftiMapsMasker title=nilearn.input_data.NiftiMapsMasker><code class="xref py py-class docutils literal notranslate"><span class=pre>NiftiMapsMasker</span></code></a>, and the same considerations on using confounds regressors apply.</p><a class="reference external image-reference"href=../auto_examples/03_connectivity/plot_probabilistic_atlas_extraction.html><img alt=../_images/sphx_glr_plot_probabilistic_atlas_extraction_0011.png src=../_images/sphx_glr_plot_probabilistic_atlas_extraction_0011.png style=width:210px;height:150px></a><div class=topic><p class=topic-title><strong>Full example</strong></p><p>A full example of extracting signals on a probabilistic: <a class="reference internal"href=../auto_examples/03_connectivity/plot_probabilistic_atlas_extraction.html#sphx-glr-auto-examples-03-connectivity-plot-probabilistic-atlas-extraction-py><span class="std std-ref">Extracting signals of a probabilistic atlas of functional regions</span></a>.</p></div><div class="green topic"><p class=topic-title><strong>Exercise: correlation matrix of rest fMRI on probabilistic atlas</strong></p><p>Try to compute the correlation matrix of the first subject of the brain development dataset downloaded with <a class="reference internal"href=../modules/generated/nilearn.datasets.fetch_development_fmri.html#nilearn.datasets.fetch_development_fmri title=nilearn.datasets.fetch_development_fmri><code class="xref py py-func docutils literal notranslate"><span class=pre>nilearn.datasets.fetch_development_fmri</span></code></a> with the MSDL atlas downloaded via <a class="reference internal"href=../modules/generated/nilearn.datasets.fetch_atlas_msdl.html#nilearn.datasets.fetch_atlas_msdl title=nilearn.datasets.fetch_atlas_msdl><code class="xref py py-func docutils literal notranslate"><span class=pre>nilearn.datasets.fetch_atlas_msdl</span></code></a>.</p><p><strong>Hint:</strong> The example above has the solution.</p></div></div></div><div class=section id=a-functional-connectome-a-graph-of-interactions><h2><a class=toc-backref href=#id5>3.1.3. A functional connectome: a graph of interactions</a><a title="Permalink to this headline"class=headerlink href=#a-functional-connectome-a-graph-of-interactions>¶</a></h2><p>A square matrix, such as a correlation matrix, can also be seen as a <a class="reference external"href=https://en.wikipedia.org/wiki/Graph_%28mathematics%29>“graph”</a>: a set of “nodes”, connected by “edges”. When these nodes are brain regions, and the edges capture interactions between them, this graph is a “functional connectome”.</p><p>We can display it with the <a class="reference internal"href=../modules/generated/nilearn.plotting.plot_connectome.html#nilearn.plotting.plot_connectome title=nilearn.plotting.plot_connectome><code class="xref py py-func docutils literal notranslate"><span class=pre>nilearn.plotting.plot_connectome</span></code></a> function that take the matrix, and coordinates of the nodes in MNI space. In the case of the MSDL atlas (<a class="reference internal"href=../modules/generated/nilearn.datasets.fetch_atlas_msdl.html#nilearn.datasets.fetch_atlas_msdl title=nilearn.datasets.fetch_atlas_msdl><code class="xref py py-func docutils literal notranslate"><span class=pre>nilearn.datasets.fetch_atlas_msdl</span></code></a>), the CSV file readily comes with MNI coordinates for each region (see for instance example: <a class="reference internal"href=../auto_examples/03_connectivity/plot_probabilistic_atlas_extraction.html#sphx-glr-auto-examples-03-connectivity-plot-probabilistic-atlas-extraction-py><span class="std std-ref">Extracting signals of a probabilistic atlas of functional regions</span></a>).</p><a class="reference external image-reference"href=../auto_examples/03_connectivity/plot_probabilistic_atlas_extraction.html><img alt=../_images/sphx_glr_plot_probabilistic_atlas_extraction_0021.png src=../_images/sphx_glr_plot_probabilistic_atlas_extraction_0021.png></a><p>As you can see, the correlation matrix gives a very “full” graph: every node is connected to every other one. This is because it also captures indirect connections. In the next section we will see how to focus on direct connections only.</p></div><div class=section id=a-functional-connectome-extracting-coordinates-of-regions><h2><a class=toc-backref href=#id6>3.1.4. A functional connectome: extracting coordinates of regions</a><a title="Permalink to this headline"class=headerlink href=#a-functional-connectome-extracting-coordinates-of-regions>¶</a></h2><p>For atlases without readily available label coordinates, center coordinates can be computed for each region on hard parcellation or probabilistic atlases.</p><blockquote><div><ul><li><p class=first>For hard parcellation atlases (eg. <a class="reference internal"href=../modules/generated/nilearn.datasets.fetch_atlas_destrieux_2009.html#nilearn.datasets.fetch_atlas_destrieux_2009 title=nilearn.datasets.fetch_atlas_destrieux_2009><code class="xref py py-func docutils literal notranslate"><span class=pre>nilearn.datasets.fetch_atlas_destrieux_2009</span></code></a>), use the <a class="reference internal"href=../modules/generated/nilearn.plotting.find_parcellation_cut_coords.html#nilearn.plotting.find_parcellation_cut_coords title=nilearn.plotting.find_parcellation_cut_coords><code class="xref py py-func docutils literal notranslate"><span class=pre>nilearn.plotting.find_parcellation_cut_coords</span></code></a> function. See example: <a class="reference internal"href=../auto_examples/03_connectivity/plot_atlas_comparison.html#sphx-glr-auto-examples-03-connectivity-plot-atlas-comparison-py><span class="std std-ref">Comparing connectomes on different reference atlases</span></a></p></li><li><p class=first>For probabilistic atlases (eg. <a class="reference internal"href=../modules/generated/nilearn.datasets.fetch_atlas_msdl.html#nilearn.datasets.fetch_atlas_msdl title=nilearn.datasets.fetch_atlas_msdl><code class="xref py py-func docutils literal notranslate"><span class=pre>nilearn.datasets.fetch_atlas_msdl</span></code></a>), use the <a class="reference internal"href=../modules/generated/nilearn.plotting.find_probabilistic_atlas_cut_coords.html#nilearn.plotting.find_probabilistic_atlas_cut_coords title=nilearn.plotting.find_probabilistic_atlas_cut_coords><code class="xref py py-func docutils literal notranslate"><span class=pre>nilearn.plotting.find_probabilistic_atlas_cut_coords</span></code></a> function. See example: <a class="reference internal"href=../auto_examples/03_connectivity/plot_multi_subject_connectome.html#sphx-glr-auto-examples-03-connectivity-plot-multi-subject-connectome-py><span class="std std-ref">Group Sparse inverse covariance for multi-subject connectome</span></a>:</p> <div class="highlight-default notranslate"><div class=highlight><pre><span></span><span class=gp>>>> </span><span class=kn>from</span> <span class=nn>nilearn</span> <span class=k>import</span> <span class=n>plotting</span>
<span class=gp>>>> </span><span class=n>atlas_region_coords</span> <span class=o>=</span> <span class=n>plotting</span><span class=o>.</span><span class=n>find_probabilistic_atlas_cut_coords</span><span class=p>(</span><span class=n>atlas_filename</span><span class=p>)</span> 
</pre></div></div></li></ul></div></blockquote><div class=line-block><div class=line><br></div></div><div class=topic><p class=topic-title><strong>References</strong></p><ul class=simple><li><a class="reference external"href=http://www.sciencedirect.com/science/article/pii/S1053811912001784>Zalesky et al., NeuroImage 2012, “On the use of correlation as a measure of network connectivity”</a>.</li><li><a class="reference external"href=http://www.sciencedirect.com/science/article/pii/S1053811913003340>Varoquaux et al., NeuroImage 2013, “Learning and comparing functional connectomes across subjects”</a>.</li></ul></div></div></div></div></div></div><div aria-label="main navigation"class=sphinxsidebar role=navigation><div class=sphinxsidebarwrapper><h4>Giving credit</h4><ul class=simple><li><p>Please consider <a href=../authors.html#citing>citing the papers</a>.</p></li></ul><h3><a href=../index.html>Table of Contents</a></h3><ul><li><a class="reference internal"href=#>3.1. Extracting times series to build a functional connectome</a><ul><li><a class="reference internal"href=#time-series-from-a-brain-parcellation-or-maxprob-atlas>3.1.1. Time-series from a brain parcellation or “MaxProb” atlas</a><ul><li><a class="reference internal"href=#brain-parcellations>3.1.1.1. Brain parcellations</a></li><li><a class="reference internal"href=#extracting-signals-on-a-parcellation>3.1.1.2. Extracting signals on a parcellation</a></li></ul></li><li><a class="reference internal"href=#time-series-from-a-probabilistic-atlas>3.1.2. Time-series from a probabilistic atlas</a><ul><li><a class="reference internal"href=#probabilistic-atlases>3.1.2.1. Probabilistic atlases</a></li><li><a class="reference internal"href=#extracting-signals-from-a-probabilistic-atlas>3.1.2.2. Extracting signals from a probabilistic atlas</a></li></ul></li><li><a class="reference internal"href=#a-functional-connectome-a-graph-of-interactions>3.1.3. A functional connectome: a graph of interactions</a></li><li><a class="reference internal"href=#a-functional-connectome-extracting-coordinates-of-regions>3.1.4. A functional connectome: extracting coordinates of regions</a></li></ul></li></ul><h4>Previous topic</h4><p class=topless><a title="previous chapter"href=index.html>3. Functional connectivity and resting state</a></p><h4>Next topic</h4><p class=topless><a title="next chapter"href=connectome_extraction.html>3.2. Connectome extraction: inverse covariance for direct connections</a></p><div id=searchbox role=search style=display:none><h3>Quick search</h3><div class=searchformwrapper><form action=../search.html class=search><input name=q><input type=submit value=Go><input name=check_keywords type=hidden value=yes><input name=area type=hidden value=default></form></div></div><script>$('#searchbox').show(0);</script></div></div><div class=clearer></div></div><div class=footer>© The nilearn developers 2010-2020. Created using <a href=http://sphinx.pocoo.org/>Sphinx</a> 1.8.5. <span style=padding-left:5ex> <a href=../_sources/connectivity/functional_connectomes.rst.txt rel=nofollow>Show this page source</a> </span></div></body></html>