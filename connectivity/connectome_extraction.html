
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Nilearn: Machine learning for NeuroImaging in Python &#8212; Machine learning for NeuroImaging</title>
    <link rel="stylesheet" href="../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/gallery.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.5.0b',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="3.2.3.1. Group-sparse covariance estimation" href="../developers/group_sparse_covariance.html" />
    <link rel="prev" title="3.1. Extracting times series to build a functional connectome" href="functional_connectomes.html" />
<meta content="True" name="HandheldFriendly">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
<meta name="keywords" content="nilearn, neuroimaging, python, neuroscience, machinelearning">


<script type="text/javascript">
function updateTopMenuPosition(height, width) {
    if($(window).scrollTop() > height && $(window).outerWidth() > 1024) {
        //begin to scroll
        $('.related-wrapper').css("z-index", 1000)
        $('.related-wrapper').css("position", "sticky")
        $('.related-wrapper').css("top", 0)
        $('.related-wrapper').css("width", width)
    } else {
        //lock it back into place
        $('.related-wrapper').css("position", "relative")
        $('.related-wrapper').css("top", 0)
    }
}

$(function() {
    var banner_height = $('#logo-banner').outerHeight()
    var banner_width = $('#logo-banner').outerWidth()
    var width = $('.related-wrapper').css("height", $('.related').outerHeight())

    updateTopMenuPosition(banner_height, width)

    $(window).scroll(function(event) {
        updateTopMenuPosition(banner_height, width)
    });

    $(window).resize(function(event) {
        var banner_width = $('#logo-banner').outerWidth()
        var menu_height = $('.related').outerHeight()
        $('.related').css("width", banner_width)
        $('.related-wrapper').css("height", menu_height)
        updateTopMenuPosition(banner_height, width)
    })
});
</script>
<script type="text/javascript">
function updateSideBarPosition(top, offset, sections) {
    var pos = $(window).scrollTop()
    // Lock the table of content to a fixed position once we scroll enough
    var topShift = 2 * offset
    if(pos > top + topShift + 1) {
        // begin to scroll with sticky menu bar
        var topShift = -topShift + 1
        if ($(window).outerWidth() < 1024) {
            // compensate top menu that disappears
            topShift -= offset + 1
        }
        $('.sphinxsidebarwrapper').css("position", "fixed")
        $('.sphinxsidebarwrapper').css("top", topShift)
    }
    else {
        //lock it back into place
        $('.sphinxsidebarwrapper').css("position", "relative")
        $('.sphinxsidebarwrapper').css("top",0)
    }

    // Highlight the current section
    i = 0
    current_section = 0
    $('a.internal').removeClass('active')
    for(i in sections) {
        if(sections[i] > pos) {
            break
        };
        if($('a.internal[href$="' + i + '"]').is(':visible')){
            current_section = i
        };
    }
    $('a.internal[href$="' + current_section + '"]').addClass('active')
    $('a.internal[href$="' + current_section + '"]').parent().addClass('active')
}

$(function () {
    // Lock the table of content to a fixed position once we scroll enough
    var tocOffset = $('.related-wrapper').outerHeight()
    var marginTop = parseFloat($('.sphinxsidebarwrapper').css('margin-top').replace(/auto/, 0))
    var top = $('.sphinxsidebarwrapper').offset().top - marginTop
    sections = {}
    url = document.URL.replace(/#.*$/, "")

    // Grab positions of our sections
    $('.headerlink').each(function(){
        sections[this.href.replace(url, '')] = $(this).offset().top - 50
    });

    updateSideBarPosition(top, tocOffset, sections)

    $(window).scroll(function(event) {
        updateSideBarPosition(top, tocOffset, sections)
    });

    $(window).resize(function(event) {
        tocOffset = $('.related-wrapper').outerHeight()
        updateSideBarPosition(top, tocOffset, sections)
    });
});
</script>


<script type="text/javascript">

        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-41920728-1']);
        _gaq.push(['_trackPageview']);

        (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();
    </script>

  </head>
  <body>
<div id="logo-banner">
  <div class="logo">
    <a href="../index.html">
      <img src="../_static/nilearn-logo.png" alt="Nilearn logo"  border="0" />
    </a>
  </div>
  <!-- A tag cloud to make it easy for people to find what they are
                         looking for -->
 <div class="tags">
  <ul>
    <li>
      <big><a href="../auto_examples/decoding/plot_haxby_anova_svm.html">SVM</a></big>
    </li>
    <li>
      <small><a href="parcellating.html">Ward
          clustering</a></small>
    </li>
    <li>
      <a href="../decoding/searchlight.html">Searchlight</a>
    </li>
    <li>
      <big><a href="resting_state_networks.html">ICA</a></big>
    </li>
    <li>
      <a href="../manipulating_images/data_preparation.html">Nifti IO</a>
    </li>
    <li>
      <a href="../modules/reference.html#module-nilearn.datasets">Datasets</a>
    </li>
  </ul>
 </div>

  <div class="banner">
    <h1>Nilearn:</h1>
    <h2>Machine learning for Neuro-Imaging in Python</h2>
  </div>
  <div class="search_form">
    <div class="gcse-search" id="cse" style="width: 100%;"></div>
    <script>
      (function() {
        var cx = '017289614950330089114:elrt9qoutrq';
        var gcse = document.createElement('script');
        gcse.type = 'text/javascript';
        gcse.async = true;
        gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
        var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(gcse, s);
      })();
    </script>
  </div>
</div>



<div class=related-wrapper>
    
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a></li>
        <li class="right" >
          <a href="../developers/group_sparse_covariance.html" title="3.2.3.1. Group-sparse covariance estimation"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="functional_connectomes.html" title="3.1. Extracting times series to build a functional connectome"
             accesskey="P">previous</a> |</li>
<li><a href="../index.html">Nilearn Home</a> |&nbsp;</li>
<li><a href="../user_guide.html">User Guide</a> |&nbsp;</li>
<li><a href="../auto_examples/index.html">Examples</a> |&nbsp;</li>
<li><a href="../modules/reference.html">Reference</a> |&nbsp;</li>
<li id="navbar-about"><a href="../authors.html">About</a>|&nbsp;</li>
<li id="navbar-ecosystem"><a href="http://www.nipy.org/">Nipy ecosystem</a></li>

          <li class="nav-item nav-item-1"><a href="../user_guide.html" >User guide: table of contents</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" accesskey="U">3. Functional connectivity and resting state</a> &#187;</li> 
      </ul>
    </div>
</div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">


<h4> Giving credit </h4>
  <ul class="simple">
    <li><p>Please consider <a href="../authors.html#citing">citing the
                    papers</a>.</p></li>
  </ul>

	   <div class="sidebartoc">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">3.2. Connectome extraction: inverse covariance for direct connections</a><ul>
<li><a class="reference internal" href="#sparse-inverse-covariance-for-functional-connectomes">3.2.1. Sparse inverse covariance for functional connectomes</a></li>
<li><a class="reference internal" href="#sparse-inverse-covariance-on-multiple-subjects">3.2.2. Sparse inverse covariance on multiple subjects</a></li>
<li><a class="reference internal" href="#comparing-the-different-approaches-on-simulated-data">3.2.3. Comparing the different approaches on simulated data</a></li>
<li><a class="reference internal" href="#linking-total-and-direct-interactions-at-the-group-level">3.2.4. Linking total and direct interactions at the group level</a></li>
</ul>
</li>
</ul>
</div>

  <h4>Previous topic</h4>
  <p class="topless"><a href="functional_connectomes.html"
                        title="previous chapter">3.1. Extracting times series to build a functional connectome</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="../developers/group_sparse_covariance.html"
                        title="next chapter">3.2.3.1. Group-sparse covariance estimation</a></p>

<script type="text/javascript">$('#searchbox-ml').show(0);</script>
<script type="text/javascript">$('#searchbox-site').show(0);</script>


        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="connectome-extraction-inverse-covariance-for-direct-connections">
<span id="connectome-extraction"></span><h1>3.2. Connectome extraction: inverse covariance for direct connections<a class="headerlink" href="#connectome-extraction-inverse-covariance-for-direct-connections" title="Permalink to this headline">¶</a></h1>
<div class="topic">
<p class="topic-title first"><strong>Page summary</strong></p>
<p>Given a set of time-series (eg as extracted in the previous section)
A <em>functional connectome</em> is a set of connections representing brain
interactions between regions. Here we show the use of sparse-inverse
covariance to extract functional connectomes focussing only on direct
interactions between regions.</p>
</div>
<div class="contents local topic" id="contents">
<p class="topic-title first"><strong>Contents</strong></p>
<ul class="simple">
<li><a class="reference internal" href="#sparse-inverse-covariance-for-functional-connectomes" id="id3">Sparse inverse covariance for functional connectomes</a></li>
<li><a class="reference internal" href="#sparse-inverse-covariance-on-multiple-subjects" id="id4">Sparse inverse covariance on multiple subjects</a></li>
<li><a class="reference internal" href="#comparing-the-different-approaches-on-simulated-data" id="id5">Comparing the different approaches on simulated data</a></li>
<li><a class="reference internal" href="#linking-total-and-direct-interactions-at-the-group-level" id="id6">Linking total and direct interactions at the group level</a></li>
</ul>
</div>
<div class="topic">
<p class="topic-title first"><strong>References</strong></p>
<ul class="simple">
<li><a class="reference external" href="http://www.sciencedirect.com/science/article/pii/S1053811910011602">Smith et al, Network modelling methods for FMRI,
NeuroImage 2011</a></li>
<li><a class="reference external" href="http://www.sciencedirect.com/science/article/pii/S1053811913003340">Varoquaux and Craddock, Learning and comparing functional
connectomes across subjects, NeuroImage 2013</a></li>
</ul>
</div>
<div class="section" id="sparse-inverse-covariance-for-functional-connectomes">
<h2><a class="toc-backref" href="#id3">3.2.1. Sparse inverse covariance for functional connectomes</a><a class="headerlink" href="#sparse-inverse-covariance-for-functional-connectomes" title="Permalink to this headline">¶</a></h2>
<p>Resting-state functional connectivity can be obtained by estimating a
covariance (or correlation) matrix for signals from different brain
regions. The same information can be represented as a weighted graph,
vertices being brain regions, weights on edges being covariances
(gaussian graphical model). However, coefficients in a covariance matrix
reflect direct as well as indirect connections. Covariance matrices form
very dense brain connectomes, and it is rather difficult to extract from
them only the direct connections between two regions.</p>
<p>As shown in <a class="reference external" href="http://www.sciencedirect.com/science/article/pii/S1053811910011602">[Smith 2011]</a>,
<a class="reference external" href="https://hal.inria.fr/inria-00512451">[Varoquaux 2010]</a>, it is more
interesting to use the inverse covariance matrix, ie the <em>precision
matrix</em>. It gives <strong>only direct connections between regions</strong>, as it
contains <em>partial covariances</em>, which are covariances between two regions
conditioned on all the others.</p>
<p>To recover well the interaction structure, a <strong>sparse inverse covariance
estimator</strong> is necessary. The GraphLasso, implemented in scikit-learn’s
estimator <a class="reference external" href="http://scikit-learn.org/0.18/modules/generated/sklearn.covariance.GraphLassoCV.html#sklearn.covariance.GraphLassoCV" title="(in scikit-learn v0.18.2)"><code class="xref py py-class docutils literal"><span class="pre">sklearn.covariance.GraphLassoCV</span></code></a> is a good, simple
solution. To use it, you need to create an estimator object:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.covariance</span> <span class="k">import</span> <span class="n">GraphLassoCV</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimator</span> <span class="o">=</span> <span class="n">GraphLassoCV</span><span class="p">()</span>
</pre></div>
</div>
<p>And then you can fit it on the activation time series, for instance
extracted in <a class="reference internal" href="functional_connectomes.html#functional-connectomes"><span class="std std-ref">the previous section</span></a>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">estimator</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">time_series</span><span class="p">)</span>  
</pre></div>
</div>
<p>The covariance matrix and inverse-covariance matrix (precision matrix)
can be found respectively in the <cite>covariance_</cite> and <cite>precision_</cite> attribute
of the estimator:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">estimator</span><span class="o">.</span><span class="n">covariance_</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimator</span><span class="o">.</span><span class="n">precision_</span>  
</pre></div>
</div>
<p class="centered">
<strong><a class="reference external" href="../auto_examples/03_connectivity/plot_inverse_covariance_connectome.html"><img alt="covariance" src="../_images/sphx_glr_plot_inverse_covariance_connectome_0011.png" style="width: 360.0px; height: 280.0px;" /></a> <a class="reference external" href="../auto_examples/03_connectivity/plot_inverse_covariance_connectome.html"><img alt="precision" src="../_images/sphx_glr_plot_inverse_covariance_connectome_0031.png" style="width: 360.0px; height: 280.0px;" /></a></strong></p><p class="centered">
<strong><a class="reference external" href="../auto_examples/03_connectivity/plot_inverse_covariance_connectome.html"><img alt="covariance_graph" src="../_images/sphx_glr_plot_inverse_covariance_connectome_0021.png" style="width: 363.0px; height: 143.0px;" /></a> <a class="reference external" href="../auto_examples/03_connectivity/plot_inverse_covariance_connectome.html"><img alt="precision_graph" src="../_images/sphx_glr_plot_inverse_covariance_connectome_0041.png" style="width: 363.0px; height: 143.0px;" /></a></strong></p><div class="topic">
<p class="topic-title first"><strong>Parameter selection</strong></p>
<p>The parameter controlling the sparsity is set by <a class="reference external" href="http://scikit-learn.org/stable/modules/cross_validation.html">cross-validation</a>
scheme. If you want to specify it manually, use the estimator
<a class="reference external" href="http://scikit-learn.org/0.18/modules/generated/sklearn.covariance.GraphLasso.html#sklearn.covariance.GraphLasso" title="(in scikit-learn v0.18.2)"><code class="xref py py-class docutils literal"><span class="pre">sklearn.covariance.GraphLasso</span></code></a>.</p>
</div>
<div class="topic">
<p class="topic-title first"><strong>Full example</strong></p>
<p>See the following example for a full file running the analysis:
<a class="reference internal" href="../auto_examples/03_connectivity/plot_inverse_covariance_connectome.html#sphx-glr-auto-examples-03-connectivity-plot-inverse-covariance-connectome-py"><span class="std std-ref">Computing a connectome with sparse inverse covariance</span></a></p>
</div>
<div class="green topic">
<p class="topic-title first"><strong>Exercise: computing sparse inverse covariance</strong></p>
<p>Compute and visualize a connectome on the first subject of the ADHD
dataset downloaded with <a class="reference internal" href="../modules/generated/nilearn.datasets.fetch_adhd.html#nilearn.datasets.fetch_adhd" title="nilearn.datasets.fetch_adhd"><code class="xref py py-func docutils literal"><span class="pre">nilearn.datasets.fetch_adhd</span></code></a></p>
<p><strong>Hints:</strong> The example above has the solution</p>
</div>
<div class="topic">
<p class="topic-title first"><strong>Reference</strong></p>
<ul class="simple">
<li>The <a class="reference external" href="http://biostatistics.oxfordjournals.org/content/9/3/432.short">graph lasso [Friedman et al, Biostatistics 2007]</a> is useful to estimate one
inverse covariance, ie to work on single-subject data or concatenate
multi-subject data.</li>
</ul>
</div>
</div>
<div class="section" id="sparse-inverse-covariance-on-multiple-subjects">
<h2><a class="toc-backref" href="#id4">3.2.2. Sparse inverse covariance on multiple subjects</a><a class="headerlink" href="#sparse-inverse-covariance-on-multiple-subjects" title="Permalink to this headline">¶</a></h2>
<p>To work at the level of a group of subject, it can be interesting to
estimate multiple connectomes for each, with a similar structure but
differing connection values across subjects.</p>
<p>For this, nilearn provides the
<a class="reference internal" href="../modules/generated/nilearn.connectome.GroupSparseCovarianceCV.html#nilearn.connectome.GroupSparseCovarianceCV" title="nilearn.connectome.GroupSparseCovarianceCV"><code class="xref py py-class docutils literal"><span class="pre">nilearn.connectome.GroupSparseCovarianceCV</span></code></a>
estimator. Its usage is similar to the GraphLassoCV object, but it takes
a list of time series:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">estimator</span><span class="o">.</span><span class="n">fit</span><span class="p">([</span><span class="n">time_series_1</span><span class="p">,</span> <span class="n">time_series_2</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span>  
</pre></div>
</div>
<p>And it provides one estimated covariance and inverse-covariance
(precision) matrix per time-series: for the first one:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">estimator</span><span class="o">.</span><span class="n">covariances_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimator</span><span class="o">.</span><span class="n">precisions_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  
</pre></div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>One specific case where this may be interesting is for group analysis
across multiple subjects. Indeed, one challenge when doing statistics on
the coefficients of a connectivity matrix is that the number of
coefficients to compare grows quickly with the number of regions, and as
a result correcting for multiple comparisons takes a heavy toll on
statistical power.</p>
<p>In such a situation, you can use the <a class="reference internal" href="../modules/generated/nilearn.connectome.GroupSparseCovariance.html#nilearn.connectome.GroupSparseCovariance" title="nilearn.connectome.GroupSparseCovariance"><code class="xref py py-class docutils literal"><span class="pre">GroupSparseCovariance</span></code></a> and
set an <cite>alpha</cite> value a bit higher than the alpha value selected by
cross-validation in the <a class="reference internal" href="../modules/generated/nilearn.connectome.GroupSparseCovarianceCV.html#nilearn.connectome.GroupSparseCovarianceCV" title="nilearn.connectome.GroupSparseCovarianceCV"><code class="xref py py-class docutils literal"><span class="pre">GroupSparseCovarianceCV</span></code></a>. Such a choice
will enforce a stronger sparsity on the precision matrices for each
subject. As the sparsity is common to each subject, you can then do the
group analysis only on the non zero coefficients.</p>
<div class="topic">
<p class="topic-title first"><strong>Full example</strong></p>
<p>See the following example for a full file running the analysis:
<a class="reference internal" href="../auto_examples/03_connectivity/plot_multi_subject_connectome.html#sphx-glr-auto-examples-03-connectivity-plot-multi-subject-connectome-py"><span class="std std-ref">Group Sparse inverse covariance for multi-subject connectome</span></a></p>
</div>
<div class="green topic">
<p class="topic-title first"><strong>Exercise: computing the correlation matrix of rest fmri</strong></p>
<p>Try using the information above to compute a connectome on the
first 5 subjects of the ADHD dataset downloaded with
<a class="reference internal" href="../modules/generated/nilearn.datasets.fetch_adhd.html#nilearn.datasets.fetch_adhd" title="nilearn.datasets.fetch_adhd"><code class="xref py py-func docutils literal"><span class="pre">nilearn.datasets.fetch_adhd</span></code></a></p>
<p><strong>Hint:</strong> The example above has the solution</p>
</div>
<div class="topic">
<p class="topic-title first"><strong>Reference</strong></p>
<ul class="simple">
<li>The <a class="reference external" href="https://hal.inria.fr/inria-00512451">group-sparse covariance [Varoquaux et al, NIPS 2010]</a></li>
</ul>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="comparing-the-different-approaches-on-simulated-data">
<h2><a class="toc-backref" href="#id5">3.2.3. Comparing the different approaches on simulated data</a><a class="headerlink" href="#comparing-the-different-approaches-on-simulated-data" title="Permalink to this headline">¶</a></h2>
<p>We simulate several sets of signals, one set representing one subject,
with different precision matrices, but sharing a common sparsity pattern:
10 brain regions, for 20 subjects.</p>
<p>A single-subject estimation can be performed using the
<a class="reference external" href="http://scikit-learn.org/0.18/modules/generated/sklearn.covariance.GraphLassoCV.html#sklearn.covariance.GraphLassoCV" title="(in scikit-learn v0.18.2)"><code class="xref py py-class docutils literal"><span class="pre">sklearn.covariance.GraphLassoCV</span></code></a> estimator from scikit-learn.</p>
<p>It is also possible to fit a graph lasso on data from every subject all
together.</p>
<p>Finally, we use the
<a class="reference internal" href="../modules/generated/nilearn.connectome.GroupSparseCovarianceCV.html#nilearn.connectome.GroupSparseCovarianceCV" title="nilearn.connectome.GroupSparseCovarianceCV"><code class="xref py py-class docutils literal"><span class="pre">nilearn.connectome.GroupSparseCovarianceCV</span></code></a> <a class="footnote-reference" href="#id2" id="id1">[1]</a>.</p>
<p>The results are the following:</p>
<a class="reference external image-reference" href="../auto_examples/03_connectivity/plot_simulated_connectome.html"><img alt="../_images/sphx_glr_plot_simulated_connectome_0011.png" src="../_images/sphx_glr_plot_simulated_connectome_0011.png" style="width: 600.0px; height: 420.0px;" /></a>
<p>The group-sparse estimation outputs matrices with
the same sparsity pattern, but different values for the non-zero
coefficients. This is not the case for the graph lasso output, which
all have similar but different structures. Note that the graph lasso
applied to all subjects at once gives a sparsity pattern close to that
obtained with the group-sparse one, but cannot provide per-subject
information.</p>
<div class="topic">
<p class="topic-title first"><strong>Full Example</strong></p>
<p>The complete source code for this example can be found here:
<a class="reference internal" href="../auto_examples/03_connectivity/plot_simulated_connectome.html#sphx-glr-auto-examples-03-connectivity-plot-simulated-connectome-py"><span class="std std-ref">Connectivity structure estimation on simulated data</span></a></p>
</div>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>A lot of technical details on the algorithm used for group-sparse
estimation and its implementation can be found in
<a class="reference internal" href="../developers/group_sparse_covariance.html"><span class="doc">Group-sparse covariance estimation</span></a>.</td></tr>
</tbody>
</table>
<div class="toctree-wrapper compound">
</div>
<div class="topic">
<p class="topic-title first"><strong>Reference</strong></p>
<ul class="simple">
<li>The <a class="reference external" href="http://papers.nips.cc/paper/4080-brain-covariance-selection-better-individual-functional-connectivity-models-using-population-prior">Brain covariance selection using population prior [Varoquaux et al, NIPS 2010]</a></li>
</ul>
</div>
</div>
<div class="section" id="linking-total-and-direct-interactions-at-the-group-level">
<h2><a class="toc-backref" href="#id6">3.2.4. Linking total and direct interactions at the group level</a><a class="headerlink" href="#linking-total-and-direct-interactions-at-the-group-level" title="Permalink to this headline">¶</a></h2>
<p>Individual connectivity patterns reflect both on covariances and inverse covariances, but in different ways. For multiple subjects, mean covariance (or correlation) and group sparse inverse covariance provide different insights into the connectivity at the group level.</p>
<p>We can go one step further by coupling the information from total (pairwise) and direct interactions in a unique group connectome. This can be done through a geometrical framework allowing to measure interactions in a common space called <strong>tangent space</strong> <a class="reference external" href="https://hal.inria.fr/inria-00512417/">[Varoquaux et al, MICCAI 2010]</a>.</p>
<p>In nilearn, this is implemented in
<a class="reference internal" href="../modules/generated/nilearn.connectome.ConnectivityMeasure.html#nilearn.connectome.ConnectivityMeasure" title="nilearn.connectome.ConnectivityMeasure"><code class="xref py py-class docutils literal"><span class="pre">nilearn.connectome.ConnectivityMeasure</span></code></a>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">measure</span> <span class="o">=</span> <span class="n">ConnectivityMeasure</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="s1">&#39;tangent&#39;</span><span class="p">)</span>  
</pre></div>
</div>
<p>The group connectivity is computed using all the subjects timeseries.:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">connectivities</span> <span class="o">=</span> <span class="n">measure</span><span class="o">.</span><span class="n">fit</span><span class="p">([</span><span class="n">time_series_1</span><span class="p">,</span> <span class="n">time_series_2</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">group_connectivity</span> <span class="o">=</span> <span class="n">measure</span><span class="o">.</span><span class="n">mean_</span>  
</pre></div>
</div>
<p>Deviations from this mean in the tangent space are provided in the connectivities array and can be used to compare different groups/sessions. In practice, the tangent measure can outperform the correlation and partial correlation measures, especially for noisy or heterogeneous data.</p>
<div class="topic">
<p class="topic-title first"><strong>Full example</strong></p>
<p>See the following example for a full file running the analysis:
<a class="reference internal" href="../auto_examples/03_connectivity/plot_group_level_connectivity.html#sphx-glr-auto-examples-03-connectivity-plot-group-level-connectivity-py"><span class="std std-ref">Functional connectivity matrices for group analysis of connectomes</span></a></p>
</div>
<div class="green topic">
<p class="topic-title first"><strong>Exercise: computing connectivity in tangent space</strong></p>
<p>Compute and visualize the tangent group connectome based on the NYU, OHSU and NeuroImage sites of the ADHD
dataset downloaded with <a class="reference internal" href="../modules/generated/nilearn.datasets.fetch_adhd.html#nilearn.datasets.fetch_adhd" title="nilearn.datasets.fetch_adhd"><code class="xref py py-func docutils literal"><span class="pre">nilearn.datasets.fetch_adhd</span></code></a></p>
<p><strong>Hints:</strong> The example above has the solution</p>
</div>
<div class="topic">
<p class="topic-title first"><strong>Reference</strong></p>
<ul class="simple">
<li>The <a class="reference external" href="http://link.springer.com/chapter/10.1007%2F978-3-642-15705-9_25">tangent space for connectivity [Varoquaux et al, MICCAI 2010]</a></li>
</ul>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>

    <div class="footer">
            &copy; The nilearn developers 2010-2015.
          Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.6.7.
        <span style="padding-left: 5ex;">
          <a href="../_sources/connectivity/connectome_extraction.rst.txt"
        	 rel="nofollow">Show this page source</a>
        </span>
    </div>
  </body>
</html>