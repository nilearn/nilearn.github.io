
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta property="og:title" content="3.2.3.1. Group-sparse covariance estimation" />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://nilearn.github.io/developers/group_sparse_covariance.html" />
  <meta property="og:site_name" content="Nilearn" />
  <meta property="og:description" content="This page gives technical information on the group_sparse_covariance function and related. This is mainly useful for developers or people that want to know more about implementation. Description: g..." />
  <meta property="og:image" content="https://nilearn.github.io/_static/nilearn-logo.png" />
  <meta property="og:image:alt" content="Nilearn" />
  
    <title>Nilearn: Statistical Analysis for NeuroImaging in Python &#8212; Machine learning for NeuroImaging</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/nature.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-rendered-html.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="3.3. Extracting functional brain networks: ICA and related" href="../connectivity/resting_state_networks.html" />
    <link rel="prev" title="3.2. Connectome extraction: inverse covariance for direct connections" href="../connectivity/connectome_extraction.html" />
<meta content="True" name="HandheldFriendly">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
<meta name="keywords" content="nilearn, neuroimaging, python, neuroscience, machinelearning">


<script type="text/javascript">
function updateTopMenuPosition(height, width) {
    if($(window).scrollTop() > height && $(window).outerWidth() > 1024) {
        //begin to scroll
        $('.related-wrapper').css("z-index", 1000);
        $('.related-wrapper').css("position", "sticky");
        $('.related-wrapper').css("top", 0);
        $('.related-wrapper').css("width", width)
    } else {
        //lock it back into place
        $('.related-wrapper').css("position", "relative");
        $('.related-wrapper').css("top", 0)
    }
}

$(function() {
    var banner_height = $('#logo-banner').outerHeight();
    var banner_width = $('#logo-banner').outerWidth();
    var width = $('.related-wrapper').css("height", $('.related').outerHeight());

    updateTopMenuPosition(banner_height, width);

    $(window).scroll(function(event) {
        updateTopMenuPosition(banner_height, width)
    });

    $(window).resize(function(event) {
        var banner_width = $('#logo-banner').outerWidth();
        var menu_height = $('.related').outerHeight();
        $('.related').css("width", banner_width);
        $('.related-wrapper').css("height", menu_height);
        updateTopMenuPosition(banner_height, width)
    })
});
</script>
<script type="text/javascript">
function updateSideBarPosition(top, offset, sections) {
    var pos = $(window).scrollTop();
    // Lock the table of content to a fixed position once we scroll enough
    var topShift = 2 * offset;
    if(pos > top + topShift + 1) {
        // begin to scroll with sticky menu bar
        var topShift = -topShift + 1;
        if ($(window).outerWidth() < 1024) {
            // compensate top menu that disappears
            topShift -= offset + 1
        }
        $('.sphinxsidebarwrapper').css("position", "fixed");
        $('.sphinxsidebarwrapper').css("top", topShift)
    }
    else {
        //lock it back into place
        $('.sphinxsidebarwrapper').css("position", "relative");
        $('.sphinxsidebarwrapper').css("top",0)
    }

    // Highlight the current section
    i = 0;
    current_section = 0;
    $('a.internal').removeClass('active');
    for(i in sections) {
        if(sections[i] > pos) {
            break
        }
        if($('a.internal[href$="' + i + '"]').is(':visible')){
            current_section = i
        }
    }
    $('a.internal[href$="' + current_section + '"]').addClass('active');
    $('a.internal[href$="' + current_section + '"]').parent().addClass('active')
}

$(function () {
    // Lock the table of content to a fixed position once we scroll enough
    var tocOffset = $('.related-wrapper').outerHeight();
    var marginTop = parseFloat($('.sphinxsidebarwrapper').css('margin-top').replace(/auto/, 0));
    var top = $('.sphinxsidebarwrapper').offset().top - marginTop;
    sections = {};
    url = document.URL.replace(/#.*$/, "");

    // Grab positions of our sections
    $('.headerlink').each(function(){
        sections[this.href.replace(url, '')] = $(this).offset().top - 50
    });

    updateSideBarPosition(top, tocOffset, sections);

    $(window).scroll(function(event) {
        updateSideBarPosition(top, tocOffset, sections)
    });

    $(window).resize(function(event) {
        tocOffset = $('.related-wrapper').outerHeight();
        updateSideBarPosition(top, tocOffset, sections)
    });
});
</script>


<script type="text/javascript">

        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-41920728-1']);
        _gaq.push(['_trackPageview']);

        (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();
    </script>

  </head><body>
<div id="logo-banner">
  <div class="logo">
    <a href="../index.html">
      <img src="../_static/nilearn-logo.png" alt="Nilearn logo"  border="0" />
    </a>
  </div>
  <!-- A tag cloud to make it easy for people to find what they are
                         looking for -->
 <div class="tags">
  <ul>
    <li>
      <big><a href="../auto_examples/decoding/plot_haxby_anova_svm.html">SVM</a></big>
    </li>
    <li>
      <small><a href="../connectivity/parcellating.html">Ward
          clustering</a></small>
    </li>
    <li>
      <a href="../decoding/searchlight.html">Searchlight</a>
    </li>
    <li>
      <big><a href="../connectivity/resting_state_networks.html">ICA</a></big>
    </li>
    <li>
      <a href="../manipulating_images/data_preparation.html">Nifti IO</a>
    </li>
    <li>
      <a href="../modules/reference.html#module-nilearn.datasets">Datasets</a>
    </li>
  </ul>
 </div>

  <div class="banner">
    <h1>Nilearn:</h1>
    <h2>Statistics for NeuroImaging in Python</h2>
  </div>
  <div class="search_form">
    <div class="gcse-search" id="cse" style="width: 100%;"></div>
    <script>
      (function() {
        var cx = '017289614950330089114:elrt9qoutrq';
        var gcse = document.createElement('script');
        gcse.type = 'text/javascript';
        gcse.async = true;
        gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
        var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(gcse, s);
      })();
    </script>
  </div>
</div>



<div class=related-wrapper>
    
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a></li>
        <li class="right" >
          <a href="../connectivity/resting_state_networks.html" title="3.3. Extracting functional brain networks: ICA and related"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="../connectivity/connectome_extraction.html" title="3.2. Connectome extraction: inverse covariance for direct connections"
             accesskey="P">previous</a> |</li>
<li><a href="../index.html">Nilearn Home</a> |&nbsp;</li>
<li><a href="../user_guide.html">User Guide</a> |&nbsp;</li>
<li><a href="../auto_examples/index.html">Examples</a> |&nbsp;</li>
<li><a href="../modules/reference.html">Reference</a> |&nbsp;</li>
<li id="navbar-about"><a href="../authors.html">About</a>|&nbsp;</li>
<li><a href="../glossary.html">Glossary</a>|&nbsp;</li>
<li><a href="../bibliography.html">Bibliography</a>|&nbsp;</li>
<li id="navbar-ecosystem"><a href="http://www.nipy.org/">Nipy ecosystem</a></li>

          <li class="nav-item nav-item-1"><a href="../user_guide.html" >User guide: table of contents</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../connectivity/index.html" ><span class="section-number">3. </span>Functional connectivity and resting state</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../connectivity/connectome_extraction.html" accesskey="U"><span class="section-number">3.2. </span>Connectome extraction: inverse covariance for direct connections</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Nilearn: Statistical Analysis for NeuroImaging in Python</a></li> 
      </ul>
    </div>
</div>

<div class="stable-banner">
This is the <em>stable</em> documentation for the latest release of Nilearn,
the current development version is available <a href="https://nilearn.github.io/dev/index.html">here</a>.
</div>

  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="group-sparse-covariance-estimation">
<h1><span class="section-number">3.2.3.1. </span>Group-sparse covariance estimation<a class="headerlink" href="#group-sparse-covariance-estimation" title="Permalink to this headline">¶</a></h1>
<p>This page gives technical information on the
<a class="reference internal" href="../modules/generated/nilearn.connectome.group_sparse_covariance.html#nilearn.connectome.group_sparse_covariance" title="nilearn.connectome.group_sparse_covariance"><code class="xref py py-func docutils literal notranslate"><span class="pre">group_sparse_covariance</span></code></a> function and related. This is mainly
useful for developers or people that want to know more about
implementation.</p>
<div class="section" id="description">
<h2><span class="section-number">3.2.3.1.1. </span>Description<a class="headerlink" href="#description" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="../modules/generated/nilearn.connectome.group_sparse_covariance.html#nilearn.connectome.group_sparse_covariance" title="nilearn.connectome.group_sparse_covariance"><code class="xref py py-func docutils literal notranslate"><span class="pre">group_sparse_covariance</span></code></a>, and <a class="reference internal" href="../modules/generated/nilearn.connectome.GroupSparseCovariance.html#nilearn.connectome.GroupSparseCovariance" title="nilearn.connectome.GroupSparseCovariance"><code class="xref py py-class docutils literal notranslate"><span class="pre">GroupSparseCovariance</span></code></a> are
two different interfaces to an implementation of the algorithm described
in this article:</p>
<blockquote>
<div><p>Jean Honorio and Dimitris Samaras.
“Simultaneous and Group-Sparse Multi-Task Learning of Gaussian Graphical
Models”. arXiv:1207.4255 (17 July 2012). http://arxiv.org/abs/1207.4255.</p>
</div></blockquote>
<p>The goal of the algorithm is to take a set of K covariance matrices as
input, and estimate a set of K sparse precision matrices, using a
penalized maximum-likelihood criterion. The penalization has been
devised to enforce a common sparsity pattern in all precision
matrices. The structure is of a block coordinate descent, with a line
search as innermost loop.</p>
<p>The present implementation relies solely on NumPy, SciPy and Scikit-Learn.
Nilearn contains only Python code.</p>
<p>In addition to the basic algorithm described in the article, several
additions were implemented:</p>
<ul class="simple">
<li><p>computation of bounds for the regularization parameter</p></li>
<li><p>several stopping criteria</p></li>
<li><p>an ad-hoc cross-validation algorithm</p></li>
<li><p>signals synthesis for testing purposes</p></li>
</ul>
<p>These are described in the rest of this page. An overview of the design
choices and the history of the development is also given.</p>
</div>
<div class="section" id="numerical-stability">
<h2><span class="section-number">3.2.3.1.2. </span>Numerical stability<a class="headerlink" href="#numerical-stability" title="Permalink to this headline">¶</a></h2>
<p>The algorithm proved to be rather numerically stable for a wide range
of inputs. It turned out that the condition numbers of the input
matrices do not have any significant effect on numerical stability.
What is relevant is:</p>
<ul class="simple">
<li><p>covariance matrix symmetry: input covariances matrices in
<a class="reference internal" href="../modules/generated/nilearn.connectome.group_sparse_covariance.html#nilearn.connectome.group_sparse_covariance" title="nilearn.connectome.group_sparse_covariance"><code class="xref py py-func docutils literal notranslate"><span class="pre">group_sparse_covariance</span></code></a> must be as symmetric as possible.
This is true in general: a small discrepancy in symmetry tends to be
amplified. For this reason, our functions computing covariances ensure
symmetry.</p></li>
<li><p>covariance matrix normalization: using correlation matrices or
signals with unit variance is mandatory when a large number of
signals is to be processed.</p></li>
<li><p>normalization of the number of samples: the objective to be
optimized contains a sum of terms weighted by the number of samples
available for each subject. The sum of these weights must be
normalized to a small constant number (1 in the current
implementation). Failing to do this leads quickly to instability,
because too large numbers are used in the computation.</p></li>
<li><p>an on-line computation of an inverse is performed in function
<cite>_update_submatrix</cite>. For large problems, this is faster than
computing the full inverse each time, but gives unfortunately less
precision. In particular, symmetry is not always perfect, that’s why
it is enforced at the end on the final result.</p></li>
<li><p>the Newton-Raphson tolerance value has no influence on numerical
stability, unless very large values (like 0.5) are used.</p></li>
</ul>
<p>The <cite>debug</cite> keyword in <a class="reference internal" href="../modules/generated/nilearn.connectome.group_sparse_covariance.html#nilearn.connectome.group_sparse_covariance" title="nilearn.connectome.group_sparse_covariance"><code class="xref py py-func docutils literal notranslate"><span class="pre">group_sparse_covariance</span></code></a> activates a set
of numerical consistency checks (mainly that matrices are s.p.d.) that
can be useful to track down numerical instability problems.</p>
</div>
<div class="section" id="execution-time">
<h2><span class="section-number">3.2.3.1.3. </span>Execution time<a class="headerlink" href="#execution-time" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference external" href="http://pythonhosted.org/line_profiler/">line profiler</a> from
Robert Kern was used to locate execution time bottlenecks. Its
overhead proved not to be negligible (around 50% more execution time
when activated), and not evenly distributed in code lines. Global
execution times have also been measured to ensure that the findings
were valid. As the code in <a class="reference internal" href="../modules/generated/nilearn.connectome.group_sparse_covariance.html#nilearn.connectome.group_sparse_covariance" title="nilearn.connectome.group_sparse_covariance"><code class="xref py py-func docutils literal notranslate"><span class="pre">group_sparse_covariance</span></code></a> is highly
serial, and rather low-level, some lines have to be executed a very
large number of times (10^6 times is easily reached), one of the
bottlenecks is thus the Python interpreter overhead. Optimizing then
boils down to reducing the number of code lines and function calls in
the most executed parts: the Newton-Raphson (line search) loop. It is
for this reason that it has been written inline instead of calling
Scipy’s version (it saves a lot of lines and calls). A lot of small
optimizations of this kind have been done. It is possible that some of
these optimizations give less numerical precision that the naive
operation. But the original author could not tell.</p>
<p>Speed optimization has been performed by checking the wall-clock time
required to get to a given precision, and not the number of
iterations. This is what “fast” means in practice: short overall
execution time. Tuning of the Newton-Raphson (NR) loop gives a good
example of the validity of this approach: the goal was to set the
tolerance on the result. Using a large value reduces the number of
iterations for NR, saving a lot of time. On the other hand, a loose
tolerance increases the number of iterations in the coordinate descent
loop, therefore increasing the overall execution time. Measurement
proved that tight tolerances were leading to faster convergence rates.</p>
<p>Care has been taken to use proper ordering of data in arrays. In
particular, three-dimensional arrays containing precision matrices are
in Fortran order, to get prec[…, k] contiguous for any k. This is
important to avoid copies by lapack/atlas functions, such as matrix
inverse or dot product. It is also consistent with arrays returned by
<cite>nibabel.load</cite>.</p>
<p>An optimization that can be performed, but couldn’t be implemented
short of having proper linalg functions for it is to process only half
of each matrix: all are symmetric. This would improve numerical
stability while saving some execution time. Part of this could be done
with versions of Scipy that weren’t available on the targeted systems
at the time of writing (Ubuntu 10.04 and 12.04).</p>
<p>Memory optimization hasn’t been performed, because all functions
process covariance matrices only, that are quite small compared to the
signals from which they are generated.</p>
</div>
<div class="section" id="synthetic-dataset">
<h2><span class="section-number">3.2.3.1.4. </span>Synthetic dataset<a class="headerlink" href="#synthetic-dataset" title="Permalink to this headline">¶</a></h2>
<p>For testing purposes, a function for synthesis of signals based on
sparse precision matrices has been written:
<cite>nilearn._utils.data_gen.generate_group_sparse_gaussian_graphs</cite>.
Synthesizing such signals is a hard problem that wasn’t solved in the
present implementation. It is hopefully good enough.</p>
<p>This function generates n_subjects time, n_features signals with a
variable number of samples. Every subject has the same number of
features (i.e. signals), for a given subject every signal has the same
number of samples, but between two subjects, the sample number can
differ. This structure is close to what is available in practice.</p>
<p>Here is how signals are generated:</p>
<ul class="simple">
<li><p>a “topology” matrix containing only zero and ones is generated. This
will govern the sparsity pattern of the precision matrices.</p></li>
<li><p>for each subject, a precision matrix is generated by replacing every
1 in the topology matrix by a random positive number, then
multiplying the resulting matrix by its transpose to get a positive
definite matrix. This is a way to get a sparse definite positive
matrix.</p></li>
<li><p>inverting precision matrices gives covariance matrices, that are in
turn used to generate signals.</p></li>
</ul>
<p>The hardest part is generating sparse symmetric positive definite
matrices, while controlling the sparsity level. With the present
scheme, only the location of zeros in the <em>square root</em> of the
precision matrices can be specified. Therefore the final sparsity
level depends not only on the initial sparsity level, but also on the
precise location of zeros. Two different sparsity patterns with the
same number of zeros can lead to two significantly different sparsity
level in precision matrices. In practice, it means that for a given
value of the <cite>density</cite> parameter in
<cite>nilearn._utils.data_gen.generate_group_sparse_gaussian_graphs</cite>,
the actual number of zeros in the precision matrices can fluctuate
widely depending on the random number generation.</p>
<p>The condition number of the precision matrices depends on the range of
numbers used to fill the off-diagonal part. The shorter the range (and
the closer to zero) the lower the condition number.</p>
<p>This generator is useful for debugging and testing. However, the
signals obtained are significantly different from those from
experimental data. Some unrealistic features: each signal has a
perfectly white spectrum (any two samples are decorrelated), and there
is no global additive noise (no confounds whatsoever).</p>
</div>
<div class="section" id="stopping-criteria">
<h2><span class="section-number">3.2.3.1.5. </span>Stopping criteria<a class="headerlink" href="#stopping-criteria" title="Permalink to this headline">¶</a></h2>
<p>As with any iterative algorithm, iteration should be stopped at some
point, which is still mostly an open problem. Several heuristic
techniques have been tested and implemented.</p>
<div class="section" id="maximum-number-of-iterations">
<h3><span class="section-number">3.2.3.1.5.1. </span>Maximum number of iterations<a class="headerlink" href="#maximum-number-of-iterations" title="Permalink to this headline">¶</a></h3>
<p>The simplest way of stopping optimization is to always execute a fixed
number of iterations. This is simple but most of the time gives slow
or bad results. The convergence rate highly depends on the number of
features (size of one covariance matrix), and on the value of the
regularization parameter (high values give fast convergence, and low
values slow convergence). If the requested iteration number is too low,
large or weakly regularized problems will be far from the optimum. On
the other hand, if the requested iteration number is too large, a lot
of time is wasted for almost no gain.</p>
</div>
<div class="section" id="duality-gap">
<h3><span class="section-number">3.2.3.1.5.2. </span>Duality gap<a class="headerlink" href="#duality-gap" title="Permalink to this headline">¶</a></h3>
<p>A better way to stop iteration is to use an upper bound on the duality
gap value, since the problem is convex. This is performed in
<cite>group_sparse_covariance_costs</cite>. The article by Honorio &amp;
Samaras gives the formula for the dual cost, and proves that the
derived bound at optimum is tight (strong duality holds). However, the
dual problem is <em>not</em> solved by this algorithm, thus bounding the
duality gap away from the optimum implies finding a feasible dual
point. This proved to be quite hard in practice, because one has to
compute positive semi-definite matrices under a norm constraint.</p>
<p>What is done is computing an estimate for a dual point using the
formula relating the primal and dual points at optimum. This estimate
does not satisfies in general the norm constraint. It is then
projected on the corresponding ball. Most of the time, this is enough
to ensure the required positive definiteness of another quantity. As
the primal point is coming close to the optimal, the estimate for the
dual point also comes close to the optimal, and the initial estimate
is closer and closer to the norm ball.</p>
<p>But there are cases for which the projection is not enough to get to a
feasible point. No solution to this problem (simultaneous projection
on a norm ball and on a set of positive definite matrices) has been
found. In that case, an easier to compute but non-tight bound is used
instead.</p>
<p>In practice, using the duality gap value to stop iteration leads to
guaranteed uncertainty on the objective value, in any case. No time is
lost on over optimizing rapidly converging problems. However, the
duality gap criterion can lead to prohibitive computation time on
slowly converging cases. In practice, finding a proper value for the
duality gap uncertainty can be tricky, because it is most easily given
as an absolute uncertainty on an objective whose value highly depends
on input data.</p>
</div>
<div class="section" id="variation-of-norm-of-estimate">
<h3><span class="section-number">3.2.3.1.5.3. </span>Variation of norm of estimate<a class="headerlink" href="#variation-of-norm-of-estimate" title="Permalink to this headline">¶</a></h3>
<p>Depending on the application at hand, giving an uncertainty on the
precision matrices instead of the objective can be useful. This is
partly achieved by computing the change of the precision estimate
between two iterations. Optimization is stopped once this value goes
below a threshold. The maximum norm (maximum of the absolute value of
the difference) is used in the current implementation. It ensures that
all coefficients vary less than the threshold when optimization is
stopped.</p>
<p>This technique it is only a way to stop iterating based on the
estimate value instead of the criterion value. It does <em>not</em> ensure a
given uncertainty on the estimate. This has been tested on synthetic
and real fMRI data: using two different starting points leads to two
estimates that can differ (in max norm) by more than the threshold
(see next paragraph). However, it has the same property as the duality
gap criterion: quickly converging cases use fewer iterations than
slower cases. From a performance point of view, this is a good thing.</p>
<p>One advantage of this criterion is that the threshold value does not
depend significantly on the input data. Matrix coefficients can be
requested to change less than e.g. 0.1 for any size of the input.</p>
</div>
<div class="section" id="initial-estimate-value">
<h3><span class="section-number">3.2.3.1.5.4. </span>Initial estimate value<a class="headerlink" href="#initial-estimate-value" title="Permalink to this headline">¶</a></h3>
<p>One of the possible way to reduce the computation time of an iterating
algorithm is to start with a initial guess that is as close as
possible to the optimum. In the present case, two initializations were
tested: using a diagonal matrix (with variance of input signals), or
using a Ledoit-Wolf estimate. It turned out that even if the
Ledoit-Wolf initialization allows for starting with a better value for
the objective, the difference with the diagonal matrix initialization
dwindles rather fast. It does not allow any significant speedup
in practice.</p>
<p>Only initialization by the diagonal matrix, as
in the original paper, has been implemented.</p>
</div>
<div class="section" id="modifying-the-stopping-criterion">
<h3><span class="section-number">3.2.3.1.5.5. </span>Modifying the stopping criterion<a class="headerlink" href="#modifying-the-stopping-criterion" title="Permalink to this headline">¶</a></h3>
<p>Modifying the stopping criterion is more complicated than specifying
the initial estimate, since it requires to gain access to the
algorithm internals. This is achieved by a technique close to
aspect-oriented programming: a function can be provided by the user,
that will be called after each iteration, with all internal values as
parameter. If that function returns True, iteration is stopped.
Changing the stopping criterion is thus just a matter of writing a
function and passing it to <a class="reference internal" href="../modules/generated/nilearn.connectome.group_sparse_covariance.html#nilearn.connectome.group_sparse_covariance" title="nilearn.connectome.group_sparse_covariance"><code class="xref py py-func docutils literal notranslate"><span class="pre">group_sparse_covariance</span></code></a>. The same
feature can be used to study the algorithm convergence properties. An
example is the <cite>EarlyStopProbe</cite> class used by the
cross-validation object.</p>
</div>
</div>
<div class="section" id="cross-validation-algorithm">
<h2><span class="section-number">3.2.3.1.6. </span>Cross-validation algorithm<a class="headerlink" href="#cross-validation-algorithm" title="Permalink to this headline">¶</a></h2>
<p>An ad-hoc cross-validation scheme has been implemented in the
<a class="reference internal" href="../modules/generated/nilearn.connectome.GroupSparseCovarianceCV.html#nilearn.connectome.GroupSparseCovarianceCV" title="nilearn.connectome.GroupSparseCovarianceCV"><code class="xref py py-class docutils literal notranslate"><span class="pre">GroupSparseCovarianceCV</span></code></a> class. This implementation is
significantly faster than the “naive” cross-validation scheme.</p>
<p>The cross-validating object performs to distinct tasks: the first one
is to select a value for the regularization parameter, the second is
fitting the precision matrices for the selected parameter. The latter
is identical to what has been described in the previous parts, we thus
focus only on the former.</p>
<div class="section" id="principle-of-cross-validation">
<h3><span class="section-number">3.2.3.1.6.1. </span>Principle of cross-validation<a class="headerlink" href="#principle-of-cross-validation" title="Permalink to this headline">¶</a></h3>
<p>Cross-validation consists in splitting the input samples into two
different sets: train and test. For several values of the
regularization parameter, a model is fit on the train set, and the
generalization performance is assessed on the test set, by computing
the unpenalized criterion (log-likelihood) using the precisions
matrices obtained on the train set with the empirical covariances of
the test set. The chosen regularization parameter is given by the best
criterion on the test set.</p>
<p>The simplest scheme is here to fit many models, for many values of the
regularization parameter alpha, and pick up the best value afterward.
It works in any case, but is very time-consuming. A cleverer scheme
is used, that is very close to that used in the graph lasso
implementation in Scikit-Learn.</p>
</div>
<div class="section" id="bounds-on-alpha">
<h3><span class="section-number">3.2.3.1.6.2. </span>Bounds on alpha<a class="headerlink" href="#bounds-on-alpha" title="Permalink to this headline">¶</a></h3>
<p>The simplest and fastest thing is to get bounds for the value of
alpha. Above a critical value, the optimal precision matrices are
fully sparse (i.e. diagonal). This critical value depends on the input
covariance matrices, and can be obtained by <cite>compute_alpha_max</cite>.
The formula for computing this critical value can be obtained with
techniques presented in:</p>
<blockquote>
<div><p>Duchi, John, Stephen Gould, and Daphne Koller. ‘Projected Subgradient
Methods for Learning Sparse Gaussians’. ArXiv E-prints 1206 (1 June
2012): 3249.</p>
</div></blockquote>
<p>This very same method can be also used for determining a lower
critical value, for which the optimal precision matrices are fully
dense (no zero values). In practice, this critical value is zero if
there is a zero in the input matrices. For this reason, the second
value returned by <cite>compute_alpha_max</cite> is that under which all
coefficients <em>that can be non-zero</em> are non-zero in the optimal
precision matrices.</p>
</div>
<div class="section" id="iterative-grid-search">
<h3><span class="section-number">3.2.3.1.6.3. </span>Iterative grid search<a class="headerlink" href="#iterative-grid-search" title="Permalink to this headline">¶</a></h3>
<p>Getting the regularization parameter optimal value is equivalent to
finding the location of the maximum on the curve log-likelihood vs
regularization parameter. In practice this curve is rather smooth,
with only a single maximum. This can be exploited to reduce the number
of parameter values to try. The strategy used in this implementation
consists of a iterative grid search: the maximum value is searched on
a very loose grid of parameter values (by default, only 4 values are
used), then a tighter grid near the found maximum is computed, and so
on. This allows for a very precise determination of the maximum
location while reducing a lot the required evaluation number. The code
is very close to what is done in
<a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.covariance.GraphicalLassoCV.html#sklearn.covariance.GraphicalLassoCV" title="(in scikit-learn v1.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.covariance.GraphicalLassoCV</span></code></a>.</p>
</div>
<div class="section" id="warm-restart">
<h3><span class="section-number">3.2.3.1.6.4. </span>Warm restart<a class="headerlink" href="#warm-restart" title="Permalink to this headline">¶</a></h3>
<p>During each step of the grid search, a set of regularization
parameters has to been tested. The straightforward strategy consists of
running independently each fit, each optimization being started with
basically the same initial value (diagonal matrices). Execution time
can be reduced by running all optimizations sequentially, and using
the final result of one as initial value for the next. This goes
faster because it saves part of the optimization trajectory starting
with the second one. However, there is a real gain in execution time
only if the parameter values are ordered from the largest to the
smallest (and not the other way).</p>
<p>The usefulness of this scheme depends on several things. First, using
warm restart does not gives exactly the same result as running
independent optimizations, because optimization paths are not the
same. This is not an issue for cross-validation, since there are many
other larger sources of fluctuations. It has been checked that in
practice, the selected value does not change. Second, using warm
restart forces running all optimization one after another: there is no
parallelism at all. However, this is true only for a given fold: when
n folds are used, n such evaluations can be run in parallel. Thus, the
fact that warm restart gives faster evaluation compared to fixed
initialization depends on the number of folds, and the number of
computation cores. No more cores that the number of folds can be used
at the same time. Thus, if the number of folds is much smaller than
the number of usable cores, warm restart slows down computation (note
that if the goal is energy efficiency, not speed, warm restart is
always a good idea.) This argument is also valid for the iterative
grid search: if many cores are available, the brute-force grid search
is faster than the iterative scheme, just because every point can be
explored simultaneously, without waiting for the previous step to
finish. Many more evaluations are performed, but the overall running
time is limited of by the slowest evaluation. The choice of these
schemes (iterative grid search and warm restart) has been made in the
present implementation because the targeted hardware is a commodity
computer, with a moderate number of cores (4 to 16). More cores (and
memory) will probably be available in future years, these schemes
could be removed easily.</p>
</div>
<div class="section" id="stopping-criterion">
<h3><span class="section-number">3.2.3.1.6.5. </span>Stopping criterion<a class="headerlink" href="#stopping-criterion" title="Permalink to this headline">¶</a></h3>
<p>Finding the regularization parameter optimal value is equivalent to
finding a maximum. But since only the location of the maximum (not its
value) is of interest, any curve that peaks at the same location than
the log-likelihood can be used.</p>
<p>Implicitly, the curve whose maximum is sought is supposed to be
obtained after convergence for any value of alpha. This is never the
case in practice: a stopping criterion has to be used. In the present
implementation, the variation criterion gives results that seem to be
consistent with what would be obtained at convergence (that is: the
log-likelihood-vs-alpha curve seems to be close to convergence). This
can be pushed one step further: any stopping criterion that gives the
<em>same maximum location</em> can be used instead. We stress that only the
location is important: the curve can be anything apart from that.</p>
<p>It was found that stopping iteration just after the log-likelihood has
reached a maximum works in most cases. The obtained log-likelihood vs
alpha curve is different, but its maximum is the same as with the
variation criterion stopping. It is also faster (2 times to 4 times
in our tests).</p>
<p>In more detail: for a given value of alpha, start optimization. After
each step, compute the log-likelihood on the test set. If the current
value is smaller than the previous one, then stop. The variation
criterion is also computed for the rare cases when the log-likelihood
never decreases, and a maximum number of iterations is enforced,
to limit the time spent optimizing in any case.</p>
<p>It is possible to disable the first criterion with <cite>the
early_stopping</cite> keyword in <a class="reference internal" href="../modules/generated/nilearn.connectome.GroupSparseCovarianceCV.html#nilearn.connectome.GroupSparseCovarianceCV" title="nilearn.connectome.GroupSparseCovarianceCV"><code class="xref py py-class docutils literal notranslate"><span class="pre">GroupSparseCovarianceCV</span></code></a>. In that
case, only the two latter criteria are used. This provides a mean to
test for the validity of the heuristic.</p>
</div>
</div>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">


<h4> Giving credit </h4>
  <ul class="simple">
    <li><p>Please consider <a href="../authors.html#citing">citing the
                    papers</a>.</p></li>
  </ul>

  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">3.2.3.1. Group-sparse covariance estimation</a><ul>
<li><a class="reference internal" href="#description">3.2.3.1.1. Description</a></li>
<li><a class="reference internal" href="#numerical-stability">3.2.3.1.2. Numerical stability</a></li>
<li><a class="reference internal" href="#execution-time">3.2.3.1.3. Execution time</a></li>
<li><a class="reference internal" href="#synthetic-dataset">3.2.3.1.4. Synthetic dataset</a></li>
<li><a class="reference internal" href="#stopping-criteria">3.2.3.1.5. Stopping criteria</a><ul>
<li><a class="reference internal" href="#maximum-number-of-iterations">3.2.3.1.5.1. Maximum number of iterations</a></li>
<li><a class="reference internal" href="#duality-gap">3.2.3.1.5.2. Duality gap</a></li>
<li><a class="reference internal" href="#variation-of-norm-of-estimate">3.2.3.1.5.3. Variation of norm of estimate</a></li>
<li><a class="reference internal" href="#initial-estimate-value">3.2.3.1.5.4. Initial estimate value</a></li>
<li><a class="reference internal" href="#modifying-the-stopping-criterion">3.2.3.1.5.5. Modifying the stopping criterion</a></li>
</ul>
</li>
<li><a class="reference internal" href="#cross-validation-algorithm">3.2.3.1.6. Cross-validation algorithm</a><ul>
<li><a class="reference internal" href="#principle-of-cross-validation">3.2.3.1.6.1. Principle of cross-validation</a></li>
<li><a class="reference internal" href="#bounds-on-alpha">3.2.3.1.6.2. Bounds on alpha</a></li>
<li><a class="reference internal" href="#iterative-grid-search">3.2.3.1.6.3. Iterative grid search</a></li>
<li><a class="reference internal" href="#warm-restart">3.2.3.1.6.4. Warm restart</a></li>
<li><a class="reference internal" href="#stopping-criterion">3.2.3.1.6.5. Stopping criterion</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="../connectivity/connectome_extraction.html"
                        title="previous chapter"><span class="section-number">3.2. </span>Connectome extraction: inverse covariance for direct connections</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="../connectivity/resting_state_networks.html"
                        title="next chapter"><span class="section-number">3.3. </span>Extracting functional brain networks: ICA and related</a></p>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>

    <div class="footer">
            &copy; The nilearn developers 2010-2022.
          Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 4.0.2.
        <span style="padding-left: 5ex;">
          <a href="../_sources/developers/group_sparse_covariance.rst.txt"
        	 rel="nofollow">Show this page source</a>
        </span>
    </div>
  </body>
</html>