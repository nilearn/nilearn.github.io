
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/01_plotting/plot_surface_projection_strategies.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_examples_01_plotting_plot_surface_projection_strategies.py>`
        to download the full example code. or to run this example in your browser via Binder

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_01_plotting_plot_surface_projection_strategies.py:


Technical point: Illustration of the volume to surface sampling schemes
=======================================================================

In nilearn, :func:`~nilearn.surface.vol_to_surf` allows us to measure values of
a 3d volume at the nodes of a cortical mesh, transforming it into surface data.
This data can then be plotted with :func:`~nilearn.plotting.plot_surf_stat_map`
for example.

This script shows, on a toy example, where samples are drawn around each mesh
vertex. Image values are interpolated at each sample location, then these
samples are averaged to produce a value for the vertex.

Three strategies are available to choose sample locations: they can be spread
between corresponding nodes when we have two nested surfaces (e.g. a white
matter and a pial surface), along the normal at each node, or inside a ball
around each node. Don't worry too much about choosing one or the other: they
take a similar amount of time and give almost identical results for most
images. If you do have both pial and white matter surfaces (as for the
fsaverage and fsaverage5 surfaces fetched by `nilearn.datasets`) we recommend
passing both to `vol_to_surf`.

.. GENERATED FROM PYTHON SOURCE LINES 24-29

.. code-block:: Python


    from nilearn._utils.helpers import check_matplotlib

    check_matplotlib()








.. GENERATED FROM PYTHON SOURCE LINES 30-36

.. code-block:: Python

    import numpy as np
    from matplotlib import pyplot as plt
    from matplotlib import tri

    from nilearn.surface import surface








.. GENERATED FROM PYTHON SOURCE LINES 37-39

Build a mesh (of a cylinder)
----------------------------

.. GENERATED FROM PYTHON SOURCE LINES 39-52

.. code-block:: Python


    N_Z = 5
    N_T = 10
    u, v = np.mgrid[:N_T, :N_Z]
    triangulation = tri.Triangulation(u.flatten(), v.flatten())
    angles = u.flatten() * 2 * np.pi / N_T
    x, y = np.cos(angles), np.sin(angles)
    z = v.flatten() * 2 / N_Z

    mesh = [np.asarray([x, y, z]).T, triangulation.triangles]
    inner_mesh = [[0.7, 0.7, 1.0] * mesh[0], triangulation.triangles]









.. GENERATED FROM PYTHON SOURCE LINES 53-55

Get the locations from which vol_to_surf would draw its samples
---------------------------------------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 55-69

.. code-block:: Python


    nested_sample_points = surface._sample_locations_between_surfaces(
        mesh, inner_mesh, np.eye(4)
    )

    line_sample_points = surface._line_sample_locations(
        mesh, np.eye(4), segment_half_width=0.2, n_points=6
    )

    ball_sample_points = surface._ball_sample_locations(
        mesh, np.eye(4), ball_radius=0.15, n_points=20
    )









.. GENERATED FROM PYTHON SOURCE LINES 70-72

Plot the mesh and the sample locations
--------------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 72-87

.. code-block:: Python


    fig = plt.figure()
    ax = plt.subplot(projection="3d")
    ax.view_init(67, -42)
    ax.plot_trisurf(x, y, z, triangles=triangulation.triangles, alpha=0.6)
    ax.plot_trisurf(*inner_mesh[0].T, triangles=triangulation.triangles)
    ax.scatter(*nested_sample_points.T, color="r")

    for sample_points in [line_sample_points, ball_sample_points]:
        fig = plt.figure()
        ax = plt.subplot(projection="3d")
        ax.view_init(67, -42)
        ax.plot_trisurf(x, y, z, triangles=triangulation.triangles)
        ax.scatter(*sample_points.T, color="r")




.. rst-class:: sphx-glr-horizontal


    *

      .. image-sg:: /auto_examples/01_plotting/images/sphx_glr_plot_surface_projection_strategies_001.png
         :alt: plot surface projection strategies
         :srcset: /auto_examples/01_plotting/images/sphx_glr_plot_surface_projection_strategies_001.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_examples/01_plotting/images/sphx_glr_plot_surface_projection_strategies_002.png
         :alt: plot surface projection strategies
         :srcset: /auto_examples/01_plotting/images/sphx_glr_plot_surface_projection_strategies_002.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_examples/01_plotting/images/sphx_glr_plot_surface_projection_strategies_003.png
         :alt: plot surface projection strategies
         :srcset: /auto_examples/01_plotting/images/sphx_glr_plot_surface_projection_strategies_003.png
         :class: sphx-glr-multi-img





.. GENERATED FROM PYTHON SOURCE LINES 88-92

Adjust the sample locations
---------------------------
For "line" and nested surfaces, the depth parameter allows adjusting the
position of samples along the line

.. GENERATED FROM PYTHON SOURCE LINES 92-104

.. code-block:: Python


    nested_sample_points = surface._sample_locations_between_surfaces(
        mesh, inner_mesh, np.eye(4), depth=[-0.5, 0.0, 0.8, 1.0, 1.2]
    )
    fig = plt.figure()
    ax = plt.subplot(projection="3d")
    ax.view_init(67, -42)
    ax.plot_trisurf(x, y, z, triangles=triangulation.triangles, alpha=0.6)
    ax.plot_trisurf(*inner_mesh[0].T, triangles=triangulation.triangles)
    ax.scatter(*nested_sample_points.T, color="r")

    plt.show()



.. image-sg:: /auto_examples/01_plotting/images/sphx_glr_plot_surface_projection_strategies_004.png
   :alt: plot surface projection strategies
   :srcset: /auto_examples/01_plotting/images/sphx_glr_plot_surface_projection_strategies_004.png
   :class: sphx-glr-single-img






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 1.560 seconds)

**Estimated memory usage:**  106 MB


.. _sphx_glr_download_auto_examples_01_plotting_plot_surface_projection_strategies.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: binder-badge

      .. image:: images/binder_badge_logo.svg
        :target: https://mybinder.org/v2/gh/nilearn/nilearn/main?urlpath=lab/tree/notebooks/auto_examples/01_plotting/plot_surface_projection_strategies.ipynb
        :alt: Launch binder
        :width: 150 px

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_surface_projection_strategies.ipynb <plot_surface_projection_strategies.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_surface_projection_strategies.py <plot_surface_projection_strategies.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: plot_surface_projection_strategies.zip <plot_surface_projection_strategies.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
