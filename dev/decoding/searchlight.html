
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta property="og:title" content="2.5. Searchlight : finding voxels containing information" />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://nilearn.github.io/decoding/searchlight.html" />
  <meta property="og:site_name" content="Nilearn" />
  <meta property="og:description" content="This page overviews searchlight analyses and how they are approached in nilearn with the SearchLight estimator. Contents: Principle of the Searchlight, Preparing the data, Setting up the searchligh..." />
  <meta property="og:image" content="../_images/sphx_glr_plot_haxby_searchlight_001.png" />
  <meta property="og:image:alt" content="Nilearn" />
  
    <title>Nilearn: Statistical Analysis for NeuroImaging in Python &#8212; Machine learning for NeuroImaging</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/nature.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-rendered-html.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="2.6. Running scikit-learn functions for more control on the analysis" href="going_further.html" />
    <link rel="prev" title="2.4. SpaceNet: decoding with spatial structure for better maps" href="space_net.html" />
<meta content="True" name="HandheldFriendly">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
<meta name="keywords" content="nilearn, neuroimaging, python, neuroscience, machinelearning">


<script type="text/javascript">
function updateTopMenuPosition(height, width) {
    if($(window).scrollTop() > height && $(window).outerWidth() > 1024) {
        //begin to scroll
        $('.related-wrapper').css("z-index", 1000);
        $('.related-wrapper').css("position", "sticky");
        $('.related-wrapper').css("top", 0);
        $('.related-wrapper').css("width", width)
    } else {
        //lock it back into place
        $('.related-wrapper').css("position", "relative");
        $('.related-wrapper').css("top", 0)
    }
}

$(function() {
    var banner_height = $('#logo-banner').outerHeight();
    var banner_width = $('#logo-banner').outerWidth();
    var width = $('.related-wrapper').css("height", $('.related').outerHeight());

    updateTopMenuPosition(banner_height, width);

    $(window).scroll(function(event) {
        updateTopMenuPosition(banner_height, width)
    });

    $(window).resize(function(event) {
        var banner_width = $('#logo-banner').outerWidth();
        var menu_height = $('.related').outerHeight();
        $('.related').css("width", banner_width);
        $('.related-wrapper').css("height", menu_height);
        updateTopMenuPosition(banner_height, width)
    })
});
</script>
<script type="text/javascript">
function updateSideBarPosition(top, offset, sections) {
    var pos = $(window).scrollTop();
    // Lock the table of content to a fixed position once we scroll enough
    var topShift = 2 * offset;
    if(pos > top + topShift + 1) {
        // begin to scroll with sticky menu bar
        var topShift = -topShift + 1;
        if ($(window).outerWidth() < 1024) {
            // compensate top menu that disappears
            topShift -= offset + 1
        }
        $('.sphinxsidebarwrapper').css("position", "fixed");
        $('.sphinxsidebarwrapper').css("top", topShift)
    }
    else {
        //lock it back into place
        $('.sphinxsidebarwrapper').css("position", "relative");
        $('.sphinxsidebarwrapper').css("top",0)
    }

    // Highlight the current section
    i = 0;
    current_section = 0;
    $('a.internal').removeClass('active');
    for(i in sections) {
        if(sections[i] > pos) {
            break
        }
        if($('a.internal[href$="' + i + '"]').is(':visible')){
            current_section = i
        }
    }
    $('a.internal[href$="' + current_section + '"]').addClass('active');
    $('a.internal[href$="' + current_section + '"]').parent().addClass('active')
}

$(function () {
    // Lock the table of content to a fixed position once we scroll enough
    var tocOffset = $('.related-wrapper').outerHeight();
    var marginTop = parseFloat($('.sphinxsidebarwrapper').css('margin-top').replace(/auto/, 0));
    var top = $('.sphinxsidebarwrapper').offset().top - marginTop;
    sections = {};
    url = document.URL.replace(/#.*$/, "");

    // Grab positions of our sections
    $('.headerlink').each(function(){
        sections[this.href.replace(url, '')] = $(this).offset().top - 50
    });

    updateSideBarPosition(top, tocOffset, sections);

    $(window).scroll(function(event) {
        updateSideBarPosition(top, tocOffset, sections)
    });

    $(window).resize(function(event) {
        tocOffset = $('.related-wrapper').outerHeight();
        updateSideBarPosition(top, tocOffset, sections)
    });
});
</script>


<script type="text/javascript">

        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-41920728-1']);
        _gaq.push(['_trackPageview']);

        (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();
    </script>

  </head><body>
<div id="logo-banner">
  <div class="logo">
    <a href="../index.html">
      <img src="../_static/nilearn-logo.png" alt="Nilearn logo"  border="0" />
    </a>
  </div>
  <!-- A tag cloud to make it easy for people to find what they are
                         looking for -->
 <div class="tags">
  <ul>
    <li>
      <big><a href="../auto_examples/decoding/plot_haxby_anova_svm.html">SVM</a></big>
    </li>
    <li>
      <small><a href="../connectivity/parcellating.html">Ward
          clustering</a></small>
    </li>
    <li>
      <a href="#">Searchlight</a>
    </li>
    <li>
      <big><a href="../connectivity/resting_state_networks.html">ICA</a></big>
    </li>
    <li>
      <a href="../manipulating_images/data_preparation.html">Nifti IO</a>
    </li>
    <li>
      <a href="../modules/reference.html#module-nilearn.datasets">Datasets</a>
    </li>
  </ul>
 </div>

  <div class="banner">
    <h1>Nilearn:</h1>
    <h2>Statistics for NeuroImaging in Python</h2>
  </div>
  <div class="search_form">
    <div class="gcse-search" id="cse" style="width: 100%;"></div>
    <script>
      (function() {
        var cx = '017289614950330089114:elrt9qoutrq';
        var gcse = document.createElement('script');
        gcse.type = 'text/javascript';
        gcse.async = true;
        gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
        var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(gcse, s);
      })();
    </script>
  </div>
</div>



<div class=related-wrapper>
    
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a></li>
        <li class="right" >
          <a href="going_further.html" title="2.6. Running scikit-learn functions for more control on the analysis"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="space_net.html" title="2.4. SpaceNet: decoding with spatial structure for better maps"
             accesskey="P">previous</a> |</li>
<li><a href="../index.html">Nilearn Home</a> |&nbsp;</li>
<li><a href="../user_guide.html">User Guide</a> |&nbsp;</li>
<li><a href="../auto_examples/index.html">Examples</a> |&nbsp;</li>
<li><a href="../modules/reference.html">Reference</a> |&nbsp;</li>
<li id="navbar-about"><a href="../authors.html">About</a>|&nbsp;</li>
<li><a href="../glossary.html">Glossary</a>|&nbsp;</li>
<li><a href="../bibliography.html">Bibliography</a>|&nbsp;</li>
<li id="navbar-ecosystem"><a href="http://www.nipy.org/">Nipy ecosystem</a></li>

          <li class="nav-item nav-item-1"><a href="../user_guide.html" >User guide: table of contents</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" accesskey="U"><span class="section-number">2. </span>Decoding and MVPA: predicting from brain images</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Nilearn: Statistical Analysis for NeuroImaging in Python</a></li> 
      </ul>
    </div>
</div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="searchlight-finding-voxels-containing-information">
<span id="searchlight"></span><h1><span class="section-number">2.5. </span>Searchlight : finding voxels containing information<a class="headerlink" href="#searchlight-finding-voxels-containing-information" title="Permalink to this headline">¶</a></h1>
<p>This page overviews searchlight analyses and how they are approached
in nilearn with the <a class="reference internal" href="../modules/generated/nilearn.decoding.SearchLight.html#nilearn.decoding.SearchLight" title="nilearn.decoding.SearchLight"><code class="xref py py-class docutils literal notranslate"><span class="pre">SearchLight</span></code></a> estimator.</p>
<div class="contents local topic" id="contents">
<p class="topic-title"><strong>Contents</strong></p>
<ul class="simple">
<li><p><a class="reference internal" href="#principle-of-the-searchlight" id="id12">Principle of the Searchlight</a></p></li>
<li><p><a class="reference internal" href="#preparing-the-data" id="id13">Preparing the data</a></p></li>
<li><p><a class="reference internal" href="#setting-up-the-searchlight" id="id14">Setting up the searchlight</a></p></li>
<li><p><a class="reference internal" href="#visualization" id="id15">Visualization</a></p></li>
<li><p><a class="reference internal" href="#references" id="id16">References</a></p></li>
</ul>
</div>
<section id="principle-of-the-searchlight">
<h2><a class="toc-backref" href="#id12"><span class="section-number">2.5.1. </span>Principle of the Searchlight</a><a class="headerlink" href="#principle-of-the-searchlight" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="../modules/generated/nilearn.decoding.SearchLight.html#nilearn.decoding.SearchLight" title="nilearn.decoding.SearchLight"><code class="xref py py-class docutils literal notranslate"><span class="pre">SearchLight</span></code></a> analysis was introduced in [Kriegeskorte <em>et al.</em><a class="footnote-reference brackets" href="#footcite-kriegeskorte3863" id="id1">3</a>], and consists of scanning the brain with a <em>searchlight</em>.
Briefly, a ball of given radius is scanned across the brain volume and the prediction accuracy of a classifier trained on the corresponding <a class="reference internal" href="../glossary.html#term-voxel"><span class="xref std std-term">voxels</span></a> is measured.</p>
<p>Searchlights are also not limited to <a class="reference internal" href="../glossary.html#term-classification"><span class="xref std std-term">classification</span></a>; <a class="reference internal" href="../glossary.html#term-regression"><span class="xref std std-term">regression</span></a> (e.g., [Kahnt <em>et al.</em><a class="footnote-reference brackets" href="#footcite-kahnt2011549" id="id2">4</a>]) and representational similarity analysis (e.g., [Clarke and Tyler<a class="footnote-reference brackets" href="#footcite-clarke4766" id="id3">5</a>]) are other uses of searchlights.
Currently, only <a class="reference internal" href="../glossary.html#term-classification"><span class="xref std std-term">classification</span></a> and <a class="reference internal" href="../glossary.html#term-regression"><span class="xref std std-term">regression</span></a> are supported in nilearn.</p>
<div class="topic">
<p class="topic-title"><strong>Further Reading</strong></p>
<p>For a critical review on searchlights, see [Etzel <em>et al.</em><a class="footnote-reference brackets" href="#footcite-etzel2013261" id="id4">6</a>].</p>
</div>
</section>
<section id="preparing-the-data">
<h2><a class="toc-backref" href="#id13"><span class="section-number">2.5.2. </span>Preparing the data</a><a class="headerlink" href="#preparing-the-data" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="../modules/generated/nilearn.decoding.SearchLight.html#nilearn.decoding.SearchLight" title="nilearn.decoding.SearchLight"><code class="xref py py-class docutils literal notranslate"><span class="pre">SearchLight</span></code></a> requires a series of brain volumes as input, <cite>X</cite>, each with
a corresponding label, <cite>y</cite>. The number of brain volumes therefore correspond to
the number of samples used for decoding.</p>
<section id="masking">
<h3><span class="section-number">2.5.2.1. </span>Masking<a class="headerlink" href="#masking" title="Permalink to this headline">¶</a></h3>
<p>One of the main elements that distinguish <a class="reference internal" href="../modules/generated/nilearn.decoding.SearchLight.html#nilearn.decoding.SearchLight" title="nilearn.decoding.SearchLight"><code class="xref py py-class docutils literal notranslate"><span class="pre">SearchLight</span></code></a> from other
algorithms is the notion of structuring element that scans the entire volume.
This has an impact on the masking procedure.</p>
<p>Two masks are used with <a class="reference internal" href="../modules/generated/nilearn.decoding.SearchLight.html#nilearn.decoding.SearchLight" title="nilearn.decoding.SearchLight"><code class="xref py py-class docutils literal notranslate"><span class="pre">SearchLight</span></code></a>:</p>
<ul class="simple">
<li><p><em>mask_img</em> is the anatomical mask</p></li>
<li><p><em>process_mask_img</em> is a subset of the brain mask and defines the boundaries
of where the searchlight scans the volume. Often times we are interested in
only performing a searchlight within a specific area of the brain (e.g.,
frontal cortex). If no <em>process_mask_img</em> is set, then <a class="reference internal" href="../modules/generated/nilearn.decoding.SearchLight.html#nilearn.decoding.SearchLight" title="nilearn.decoding.SearchLight"><code class="xref py py-class docutils literal notranslate"><span class="pre">nilearn.decoding.SearchLight</span></code></a>
defaults to performing a searchlight over the whole brain.</p></li>
</ul>
<p><em>mask_img</em> ensures that only <a class="reference internal" href="../glossary.html#term-voxel"><span class="xref std std-term">voxels</span></a> with usable signals are included in the
searchlight. This could be a full-brain mask or a gray-matter mask.</p>
</section>
</section>
<section id="setting-up-the-searchlight">
<h2><a class="toc-backref" href="#id14"><span class="section-number">2.5.3. </span>Setting up the searchlight</a><a class="headerlink" href="#setting-up-the-searchlight" title="Permalink to this headline">¶</a></h2>
<section id="classifier">
<h3><span class="section-number">2.5.3.1. </span>Classifier<a class="headerlink" href="#classifier" title="Permalink to this headline">¶</a></h3>
<p>The classifier used by default by <a class="reference internal" href="../modules/generated/nilearn.decoding.SearchLight.html#nilearn.decoding.SearchLight" title="nilearn.decoding.SearchLight"><code class="xref py py-class docutils literal notranslate"><span class="pre">SearchLight</span></code></a> is LinearSVC with C=1 but
this can be customized easily by passing an estimator parameter to the
Searchlight. See scikit-learn documentation for <a class="reference external" href="http://scikit-learn.org/stable/supervised_learning.html">other classifiers</a>. You can
also pass scikit-learn <a class="reference external" href="https://scikit-learn.org/stable/modules/compose.html">Pipelines</a>
to the <a class="reference internal" href="../modules/generated/nilearn.decoding.SearchLight.html#nilearn.decoding.SearchLight" title="nilearn.decoding.SearchLight"><code class="xref py py-class docutils literal notranslate"><span class="pre">SearchLight</span></code></a> in order to combine estimators and preprocessing steps
(e.g., feature scaling) for your searchlight.</p>
</section>
<section id="score-function">
<h3><span class="section-number">2.5.3.2. </span>Score function<a class="headerlink" href="#score-function" title="Permalink to this headline">¶</a></h3>
<p>Metrics can be specified by the “scoring” argument to the <a class="reference internal" href="../modules/generated/nilearn.decoding.SearchLight.html#nilearn.decoding.SearchLight" title="nilearn.decoding.SearchLight"><code class="xref py py-class docutils literal notranslate"><span class="pre">SearchLight</span></code></a>, as
detailed in the <a class="reference external" href="http://scikit-learn.org/dev/modules/model_evaluation.html#the-scoring-parameter-defining-model-evaluation-rules">scikit-learn documentation</a></p>
</section>
<section id="cross-validation">
<h3><span class="section-number">2.5.3.3. </span>Cross validation<a class="headerlink" href="#cross-validation" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="../modules/generated/nilearn.decoding.SearchLight.html#nilearn.decoding.SearchLight" title="nilearn.decoding.SearchLight"><code class="xref py py-class docutils literal notranslate"><span class="pre">SearchLight</span></code></a> will iterate on the volume and give a score to each <a class="reference internal" href="../glossary.html#term-voxel"><span class="xref std std-term">voxel</span></a>.
This score is computed by running a classifier on selected <a class="reference internal" href="../glossary.html#term-voxel"><span class="xref std std-term">voxels</span></a>.
In order to make this score as accurate as possible (and avoid overfitting),
cross-validation is used.</p>
<p>Cross-validation can be defined using the “cv” argument. As it
is computationally costly, <em>K</em>-Fold cross validation with <em>K</em> = 3 is set as the
default. A <a class="reference external" href="https://scikit-learn.org/stable/modules/classes.html#splitter-classes">scikit-learn cross-validation generator</a> can also
be passed to set a specific type of cross-validation.</p>
<p>Leave-one-run-out cross-validation (LOROCV) is a common approach for searchlights.
This approach is a specific use-case of grouped cross-validation, where the
cross-validation folds are determined by the acquisition runs. The held-out fold
in a given iteration of cross-validation consist of data from a separate run,
which keeps training and validation sets properly independent. For this reason,
LOROCV is often recommended. This can be performed by using <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.LeaveOneGroupOut.html">LeaveOneGroupOut</a>,
and then setting the group/run labels when fitting the estimator.</p>
</section>
<section id="sphere-radius">
<h3><span class="section-number">2.5.3.4. </span>Sphere radius<a class="headerlink" href="#sphere-radius" title="Permalink to this headline">¶</a></h3>
<p>An important parameter is the radius of the sphere that will run through
the data. The sphere size determines the number of voxels/features to use
for <a class="reference internal" href="../glossary.html#term-classification"><span class="xref std std-term">classification</span></a> (i.e. more <a class="reference internal" href="../glossary.html#term-voxel"><span class="xref std std-term">voxels</span></a> are included with larger spheres).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><a class="reference internal" href="../modules/generated/nilearn.decoding.SearchLight.html#nilearn.decoding.SearchLight" title="nilearn.decoding.SearchLight"><code class="xref py py-class docutils literal notranslate"><span class="pre">SearchLight</span></code></a> defines sphere radius in millimeters; the number
of <a class="reference internal" href="../glossary.html#term-voxel"><span class="xref std std-term">voxels</span></a> included in the sphere will therefore depend on the
<a class="reference internal" href="../glossary.html#term-voxel"><span class="xref std std-term">voxel</span></a> size.</p>
<p>For reference, [Kriegeskorte <em>et al.</em><a class="footnote-reference brackets" href="#footcite-kriegeskorte3863" id="id5">3</a>] use a 4mm radius because it yielded
the best detection performance in their simulation of 2mm isovoxel data.</p>
</div>
</section>
</section>
<section id="visualization">
<h2><a class="toc-backref" href="#id15"><span class="section-number">2.5.4. </span>Visualization</a><a class="headerlink" href="#visualization" title="Permalink to this headline">¶</a></h2>
<section id="id6">
<h3><span class="section-number">2.5.4.1. </span>Searchlight<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<p>The results of the searchlight can be found in the <cite>scores_</cite> attribute of the
<a class="reference internal" href="../modules/generated/nilearn.decoding.SearchLight.html#nilearn.decoding.SearchLight" title="nilearn.decoding.SearchLight"><code class="xref py py-class docutils literal notranslate"><span class="pre">SearchLight</span></code></a> object after fitting it to the data. Below is a
visualization of the results from <a class="reference internal" href="../auto_examples/02_decoding/plot_haxby_searchlight.html#sphx-glr-auto-examples-02-decoding-plot-haxby-searchlight-py"><span class="std std-ref">Searchlight analysis of face
vs house recognition</span></a>.
The searchlight was restricted to a slice in the back of the brain. Within
this slice, we can see that a cluster of <a class="reference internal" href="../glossary.html#term-voxel"><span class="xref std std-term">voxels</span></a> in visual cortex
contains information to distinguish pictures showed to the volunteers,
which was the expected result.</p>
<figure class="align-center">
<a class="reference external image-reference" href="../auto_examples/02_decoding/plot_haxby_searchlight.html"><img alt="../_images/sphx_glr_plot_haxby_searchlight_001.png" src="../_images/sphx_glr_plot_haxby_searchlight_001.png" style="width: 176.0px; height: 183.20000000000002px;" /></a>
</figure>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="../plotting/index.html#plotting"><span class="std std-ref">Plotting brain images</span></a></p></li>
</ul>
</div>
</section>
<section id="comparing-to-massively-univariate-analysis-f-score-or-spm">
<h3><span class="section-number">2.5.4.2. </span>Comparing to massively univariate analysis: F_score or SPM<a class="headerlink" href="#comparing-to-massively-univariate-analysis-f-score-or-spm" title="Permalink to this headline">¶</a></h3>
<p>The standard approach to brain mapping is performed using <em>Statistical
Parametric Mapping</em> (<a class="reference internal" href="../glossary.html#term-SPM"><span class="xref std std-term">SPM</span></a>), using <a class="reference internal" href="../glossary.html#term-ANOVA"><span class="xref std std-term">ANOVA</span></a> (analysis of
variance), and parametric tests (F-tests ot t-tests).
Here we compute the <em>p-values</em> of the <a class="reference internal" href="../glossary.html#term-voxel"><span class="xref std std-term">voxels</span></a> <a class="footnote-reference brackets" href="#id9" id="id7">1</a>.
To display the results, we use the negative log of the p-value.</p>
<figure class="align-center">
<a class="reference external image-reference" href="../auto_examples/02_decoding/plot_haxby_searchlight.html"><img alt="../_images/sphx_glr_plot_haxby_searchlight_002.png" src="../_images/sphx_glr_plot_haxby_searchlight_002.png" style="width: 176.0px; height: 183.20000000000002px;" /></a>
</figure>
<p>Parametric scores can be converted into p-values using a reference
theoretical distribution, which is known under specific assumptions
(hence the name <em>parametric</em>). In practice, neuroimaging signal has a
complex structure that might not match these assumptions. An exact,
non-parametric <em>permutation test</em> can be performed as an alternative
to the parametric test: the residuals of the model are permuted so as
to break any effect and the corresponding decision statistic is
recomputed. One thus builds the distribution of the decision statistic
under the hypothesis that there is no relationship between the tested
variates and the target variates.  In neuroimaging, this is generally
done by swapping the signal values of all <a class="reference internal" href="../glossary.html#term-voxel"><span class="xref std std-term">voxels</span></a> while the tested
variables remain unchanged <a class="footnote-reference brackets" href="#id10" id="id8">2</a>. A voxel-wise analysis is then
performed on the permuted data. The relationships between the image
descriptors and the tested variates are broken while the value of the
signal in each particular <a class="reference internal" href="../glossary.html#term-voxel"><span class="xref std std-term">voxel</span></a> can be observed with the same
probability than the original value associated to that <a class="reference internal" href="../glossary.html#term-voxel"><span class="xref std std-term">voxel</span></a>.
Note that it is hereby assumed that the signal distribution is the same in
every <a class="reference internal" href="../glossary.html#term-voxel"><span class="xref std std-term">voxel</span></a>. Several data permutations are performed (typically
10,000) while the scores for every <a class="reference internal" href="../glossary.html#term-voxel"><span class="xref std std-term">voxel</span></a> and every data permutation
is stored. The empirical distribution of the scores is thus
constructed (under the hypothesis that there is no relationship
between the tested variates and the neuroimaging signal, the so-called
<em>null-hypothesis</em>) and we can compare the original scores to that
distribution: The higher the rank of the original score, the smaller
is its associated p-value. The
<a class="reference internal" href="../modules/generated/nilearn.mass_univariate.permuted_ols.html#nilearn.mass_univariate.permuted_ols" title="nilearn.mass_univariate.permuted_ols"><code class="xref py py-func docutils literal notranslate"><span class="pre">nilearn.mass_univariate.permuted_ols</span></code></a> function returns the
p-values computed with a permutation test.</p>
<p>The number of tests performed is generally large when full-brain
analysis is performed (&gt; 50,000 voxels). This increases the
probability of finding a significant activation by chance, a
phenomenon that is known to statisticians as the <em>multiple comparisons
problem</em>. It is therefore recommended to correct the p-values to take
into account the multiple tests. <em>Bonferroni correction</em> consists of
multiplying the p-values by the number of tests (while making sure the
p-values remain smaller than 1). Thus, we control the occurrence of one
false detection <em>at most</em>, the so-called <em>family-wise error control</em>.
A similar control can be performed when performing a permutation test:
For each permutation, only the maximum value of the F-statistic across
<a class="reference internal" href="../glossary.html#term-voxel"><span class="xref std std-term">voxels</span></a> is considered and is used to build the null distribution.
It is crucial to assume that the distribution of the signal is the same in
every <a class="reference internal" href="../glossary.html#term-voxel"><span class="xref std std-term">voxel</span></a> so that the F-statistics are comparable.
This correction strategy is applied in nilearn
<a class="reference internal" href="../modules/generated/nilearn.mass_univariate.permuted_ols.html#nilearn.mass_univariate.permuted_ols" title="nilearn.mass_univariate.permuted_ols"><code class="xref py py-func docutils literal notranslate"><span class="pre">nilearn.mass_univariate.permuted_ols</span></code></a> function.</p>
<figure class="align-center">
<a class="reference external image-reference" href="../auto_examples/07_advanced/plot_haxby_mass_univariate.html"><img alt="../_images/sphx_glr_plot_haxby_mass_univariate_001.png" src="../_images/sphx_glr_plot_haxby_mass_univariate_001.png" style="width: 174.0px; height: 137.4px;" /></a>
</figure>
<p>We observe that the results obtained with a permutation test are less
conservative than the ones obtained with a Bonferroni correction
strategy.</p>
<p>In nilearn <a class="reference internal" href="../modules/generated/nilearn.mass_univariate.permuted_ols.html#nilearn.mass_univariate.permuted_ols" title="nilearn.mass_univariate.permuted_ols"><code class="xref py py-func docutils literal notranslate"><span class="pre">nilearn.mass_univariate.permuted_ols</span></code></a> function, we
permute a parametric t-test. Unlike F-test, a t-test can be signed
(<em>one-sided test</em>), that is both the absolute value and the sign of an
effect are considered. Thus, only positive effects
can be focused on.  It is still possible to perform a two-sided test
equivalent to a permuted F-test by setting the argument
<cite>two_sided_test</cite> to <cite>True</cite>. In the example above, we do perform a two-sided
test but add back the sign of the effect at the end using the t-scores obtained
on the original (non-permuted) data. Thus, we can perform two one-sided tests
(a given contrast and its opposite) for the price of one single run.
The example results can be interpreted as follows: viewing faces significantly
activates the Fusiform Face Area as compared to viewing houses, while viewing
houses does not reveal significant supplementary activations as compared to
viewing faces.</p>
<dl class="footnote brackets">
<dt class="label" id="id9"><span class="brackets"><a class="fn-backref" href="#id7">1</a></span></dt>
<dd><p>The <em>p-value</em> is the probability of getting the observed values
assuming that nothing happens (i.e. under the null hypothesis).
Therefore, a small <em>p-value</em> indicates that there is a small chance
of getting this data if no real difference existed, so the observed
voxel must be significant.</p>
</dd>
<dt class="label" id="id10"><span class="brackets"><a class="fn-backref" href="#id8">2</a></span></dt>
<dd><p>When the variate tested is a scalar (test of the <em>intercept</em>)
–which corresponds to a one sample test–, no swapping can be
performed but one can estimate the null distribution by assuming
symmetry about some reference value. When this value is zero, one can
randomly swap the sign of the target variates (the imaging
signal). nilearn
<a class="reference internal" href="../modules/generated/nilearn.mass_univariate.permuted_ols.html#nilearn.mass_univariate.permuted_ols" title="nilearn.mass_univariate.permuted_ols"><code class="xref py py-func docutils literal notranslate"><span class="pre">nilearn.mass_univariate.permuted_ols</span></code></a> function automatically
adopts the suitable strategy according to the input data.</p>
</dd>
</dl>
<div class="topic">
<p class="topic-title"><strong>Example code</strong></p>
<p>All the steps discussed in this section can be seen implemented in
<a class="reference internal" href="../auto_examples/02_decoding/plot_haxby_searchlight.html#sphx-glr-auto-examples-02-decoding-plot-haxby-searchlight-py"><span class="std std-ref">a full code example</span></a>.</p>
</div>
</section>
</section>
<section id="references">
<h2><a class="toc-backref" href="#id16"><span class="section-number">2.5.5. </span>References</a><a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<p id="id11"><dl class="footnote brackets">
<dt class="label" id="footcite-kriegeskorte3863"><span class="brackets">3</span><span class="fn-backref">(<a href="#id1">1</a>,<a href="#id5">2</a>)</span></dt>
<dd><p>Nikolaus Kriegeskorte, Rainer Goebel, and Peter Bandettini. Information-based functional brain mapping. <em>Proceedings of the National Academy of Sciences</em>, 103(10):3863–3868, 2006. URL: <a class="reference external" href="https://www.pnas.org/content/103/10/3863">https://www.pnas.org/content/103/10/3863</a>, <a class="reference external" href="https://doi.org/10.1073/pnas.0600244103">doi:10.1073/pnas.0600244103</a>.</p>
</dd>
<dt class="label" id="footcite-kahnt2011549"><span class="brackets"><a class="fn-backref" href="#id2">4</a></span></dt>
<dd><p>Thorsten Kahnt, Marcus Grueschow, Oliver Speck, and John-Dylan Haynes. Perceptual learning and decision-making in human medial frontal cortex. <em>Neuron</em>, 70(3):549–559, 2011. URL: <a class="reference external" href="https://www.sciencedirect.com/science/article/pii/S0896627311002960">https://www.sciencedirect.com/science/article/pii/S0896627311002960</a>, <a class="reference external" href="https://doi.org/https://doi.org/10.1016/j.neuron.2011.02.054">doi:https://doi.org/10.1016/j.neuron.2011.02.054</a>.</p>
</dd>
<dt class="label" id="footcite-clarke4766"><span class="brackets"><a class="fn-backref" href="#id3">5</a></span></dt>
<dd><p>Alex Clarke and Lorraine K. Tyler. Object-specific semantic coding in human perirhinal cortex. <em>Journal of Neuroscience</em>, 34(14):4766–4775, 2014. URL: <a class="reference external" href="https://www.jneurosci.org/content/34/14/4766">https://www.jneurosci.org/content/34/14/4766</a>, <a class="reference external" href="https://arxiv.org/abs/https://www.jneurosci.org/content/34/14/4766.full.pdf">arXiv:https://www.jneurosci.org/content/34/14/4766.full.pdf</a>, <a class="reference external" href="https://doi.org/10.1523/JNEUROSCI.2828-13.2014">doi:10.1523/JNEUROSCI.2828-13.2014</a>.</p>
</dd>
<dt class="label" id="footcite-etzel2013261"><span class="brackets"><a class="fn-backref" href="#id4">6</a></span></dt>
<dd><p>Joset A. Etzel, Jeffrey M. Zacks, and Todd S. Braver. Searchlight analysis: promise, pitfalls, and potential. <em>NeuroImage</em>, 78:261–269, 2013. URL: <a class="reference external" href="https://www.sciencedirect.com/science/article/pii/S1053811913002917">https://www.sciencedirect.com/science/article/pii/S1053811913002917</a>, <a class="reference external" href="https://doi.org/https://doi.org/10.1016/j.neuroimage.2013.03.041">doi:https://doi.org/10.1016/j.neuroimage.2013.03.041</a>.</p>
</dd>
</dl>
</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">


<h4> Giving credit </h4>
  <ul class="simple">
    <li><p>Please consider <a href="../authors.html#citing">citing the
                    papers</a>.</p></li>
  </ul>

  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">2.5. Searchlight : finding voxels containing information</a><ul>
<li><a class="reference internal" href="#principle-of-the-searchlight">2.5.1. Principle of the Searchlight</a></li>
<li><a class="reference internal" href="#preparing-the-data">2.5.2. Preparing the data</a><ul>
<li><a class="reference internal" href="#masking">2.5.2.1. Masking</a></li>
</ul>
</li>
<li><a class="reference internal" href="#setting-up-the-searchlight">2.5.3. Setting up the searchlight</a><ul>
<li><a class="reference internal" href="#classifier">2.5.3.1. Classifier</a></li>
<li><a class="reference internal" href="#score-function">2.5.3.2. Score function</a></li>
<li><a class="reference internal" href="#cross-validation">2.5.3.3. Cross validation</a></li>
<li><a class="reference internal" href="#sphere-radius">2.5.3.4. Sphere radius</a></li>
</ul>
</li>
<li><a class="reference internal" href="#visualization">2.5.4. Visualization</a><ul>
<li><a class="reference internal" href="#id6">2.5.4.1. Searchlight</a></li>
<li><a class="reference internal" href="#comparing-to-massively-univariate-analysis-f-score-or-spm">2.5.4.2. Comparing to massively univariate analysis: F_score or SPM</a></li>
</ul>
</li>
<li><a class="reference internal" href="#references">2.5.5. References</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="space_net.html"
                        title="previous chapter"><span class="section-number">2.4. </span>SpaceNet: decoding with spatial structure for better maps</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="going_further.html"
                        title="next chapter"><span class="section-number">2.6. </span>Running scikit-learn functions for more control on the analysis</a></p>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>

    <div class="footer">
            &copy; The nilearn developers 2010-2021.
          Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 4.2.0.
        <span style="padding-left: 5ex;">
          <a href="../_sources/decoding/searchlight.rst.txt"
        	 rel="nofollow">Show this page source</a>
        </span>
    </div>
  </body>
</html>